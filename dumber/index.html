<DOCTYPE html>
<html lang="en">
  <head>
    <title>⚐ Dumber</title>
    <meta charset="UTF-8">
    <meta http-equiv="cache-control" content="no-cache">
    <style>
      body { font-family: Univers, "Helvetica Neue", Helvetica, sans-serif;
        width: 960px; margin: auto; font-size: 16px;
        background-color: #fef9f0; }
      header { border-top: solid 2px #ff7f40; }
      #manual { border-top: solid 2px #40ff40; }
      #demos, #library, #tests { border-top: solid 2px #40bfff; }
      footer { clear: both; padding: 40px 0; font-size: 12px;
        text-align: center; border-bottom: solid 2px #ff7f40; }
      h1, h2, h3 { font-weight: normal; color: #102040; }
      .g4, .g8, .g12 { display: inline; float: left; position: relative;
        margin: 0 10px; }
      .g4 { width: 300px; }
      .g8 { width: 620px; }
      .g12 { width: 940px; }
      .clear { clear: both; display: block; overflow: hidden;
        visibility: hidden; width: 0; height: 0; }
      code, pre { font-family: Menlo, Consolas, monospace; font-size: 14px; }
      a { color: #ff4040; text-decoration: none; }
      .def { background-color: #ff0; }
      .node { background-color: #8f8; }
      .prop, .param, .attr { background-color: #8ff; }
      .TODO { background-color: #ddd; }
      .sample { margin-left: 2em; }
    </style>
  </head>
  <body>

    <header class="g12">
      <h1>Dumber</h1>
      <p>Dumber is a simpler implementation of Bender intended to prototype
      dynamic rendering of components.</p>
    </header>

    <section id="manual" class="g8">
      <h2>Manual</h2>

      <section id="manual.start">
        <h3>Getting started</h3>
        <p>Using Dumber just requires including the <a
        href="../flexo.js"><code>flexo.js</code></a> (the support library for
        Dumber) and <a href="dumber.js"><code>dumber.js</code></a> Javascript
        files in the host document (<em>e.g.</em>, in <code>script</code>
        tags.) See for example the test documents in the sidebar. Note that it
        makes <code>flexo.js</code> the <em>de facto</em> utility library for
        Dumber applications; but other frameworks may be used freely. <span
        class="TODO">TODO: check with D3, Prototype, or Bootstrap, for
        example.</span></p>
        <p>Dumber content may then be rendered in the running document as a
        complete application, or individual components may be inserted in the
        document. The Dumber content may be read from XML description files or
        created on the fly through scripting.</p>
      </section>

      <section id="manual.context">
        <h3>The context</h3>
        <p>The <em>context</em> is the document hosting Dumber elements. The
        root of the document is a <code>context</code> element, which should
        only be used as the root a Dumber tree. <code
        class="def">dumber.create_context(target)</code> creates a new context
        with a rendering target specified by <code class="param">target</code>
        (or the current document by default.) If the target is a DOM
        <code>Element</code> (<em>e.g.</em> the body of an HTML document, or a
        <code>g</code> element in an SVG document), rendered nodes will be
        appended to the given target. In other cases (<em>e.g.</em>, when the
        target is a <code>Document</code> node, which is the default),
        individual components may be rendered by specifying a target node. The
        <code class="param">context</code> root element is returned (not the
        context document itself, which can be accessed through the DOM
        <code>ownerDocument</code> property of any node in the document.)</p>
      </section>

      <section id="manual.elements">
        <h3>Dumber elements</h3>
        <p>Elements in the Dumber tree overload common DOM methods so that
        changes can be tracked and reflected after rendering was done. Dumber
        elements, <em>i.e.</em>, all elements created through the Dumber context
        (including foreign elements), have a convenience method
        <code class="def">$(name, attributes, ...)</code> to create new
        nodes.</p>
        <ul>
          <li>The <code class="param">name</code> parameter is the name of the
          element to be created and may be qualified by a known namespace prefix
          (<code>html</code> or <code>xhtml</code>, <code>svg</code>,
          <code>xlink</code>, <code>xml</code>, <code>xmlns</code>; the Dumber
          namespace <code>http://dumber.igel.co.jp</code> is used if there is no
          prefix) and may include an id prefixed by <code>#</code> and a list of
          class names prefixed by <code>.</code>. For example, the name string
          <code>html:div#body.calculator</code> describes an HTML
          <code>div</code> element with id <code>body</code> and class
          <code>calculator</code>, while <code>use</code> describes a Dumber
          <code>use</code> element.</li>
          <li>The <code class="param">attributes</code> parameters is an object
          in which keys are attribute names and values attribute values to be
          set for the new element. For example, <code>{ q: "app" }</code> sets
          the <code>q</code> attribute to <code>app</code> for the element being
          created. A <code>null</code> or <code>undefined</code> value for an
          attribute will not set it. This parameter may be empty or
          omitted.</li>
          <li>The remaining parameters, if any, are the contents of the element.
          Valid content is either a string, which creates a text node, or other
          elements, usually created themselves through the <code>$</code>
          method.</li>
        </ul>
        <p>Node manipulation is done through the DOM methods <code
          class="def">appendChild</code>, <code class="def">insertBefore</code>,
        <code class="def">setAttribute</code>, and <code
        class="def">setAttributeNS</code>. Additionally, Dumber elements have a
        <code class="def">_textContent(text)</code> method to replace setting
        the <code>textContent</code> property, which can still be read normally
        (and also be set, but changes will not cause the rendering to update.)
        Dumber elements have an internal method <code class="def
        internal">_refresh(parent)</code> which will refresh the rendering for
        the parent of this element (which defaults to <code>parentNode</code> if
        not specified; the parameter is needed mostly for updates after an
        element was removed from its parent.) It should not be necessary to call
        this method under normal circumstances.</p>
        <p>Since a Dumber tree may be modified at runtime, it can be serialized
        again through the <code class="def">_serialize()</code> method. This
        simply returns a text string of the XML serialization of the current
        state of the Dumber tree. This method is available on any element, so it
        may be used for instance for the main application or a given component
        rather than the full context.</p>

        <section id="manual.elements.component">
          <h4>The component, app and context elements</h4>
          <p>The <code class="node">component</code> element describes a Dumber
          component.  <code class="node">app</code> is synonymous with
          <code>component</code> and is provided to describe the main component
          of a Dumber application. <code class="node">context</code> is also a
          synonym and is used as the root of the Dumber tree (and as such should
          not be used elsewhere.) A component may have metadata, a view,
          scripts, watches, and sub-components. These are described by the
          following elements:</p>
          <ul>
            <li><code class="node">component</code> describes sub-components of
            this component;</li>
            <li><code class="node">desc</code> contains textual description for
            the component. This is used as metadata; for intance, it can be used
            to give hints about the usage of this component.</li>
            <li><code class="node">script</code> allows customizing the
            component through Javascript.</li>
            <li><code class="node">title</code> contains the title of the
            component as plain text. This is used mostly as metadata, but gets
            rendered as the document title when it is the child of an
            <code>app</code> element which in turn is the child of a
            <code>context</code> root element.</li>
            <li><code class="node">use</code> creates a new instance of a
            component and renders it in this component's view (including in a
            <node>context</code> element; see below.) <code>use</code> elements
            should appear as descendants of the <code>view</code> element of the
            component.</li>
            <li><code class="node">view</code> contains foreign and text nodes
            that will be rendered in the target document when this component is
            rendered. A component may have only one view; setting a new view
            automatically replaces the previous one.</li>
            <li><code class="node">watch</code> describes the behavior of the
            component in the face of changes in its properties and events it
            receives. See the section on watches below.</li>
          </ul>
          <p>All Dumber elements may have an <code class="attr">id</code>
          attribute which should be unique in the document where the element
          appears (if importing elements from different documents, elements with
          the same id can be distinguished by the URL of the original document.)
          These ids are not rendered since many instances of the same component
          may be rendered in a document. Dumber elements have an
          <code class="param">_id</code> property matching that attribute.</p>
        </section>

        <section id="manual.elements.use">
          <h4>The use element</h4>
          <p>The <code class="node">use</code> element instantiates and renders
          a component. For every <code>use</code> element, a new
          <em>instance</em> of a component is created; if this component has a
          view, or has <code>use</code> children, then these get rendered in
          its place.</p>
          <p>The component to be instantiated is designated by one of the
          following attributes:</p>
          <ul>
            <li><code class="attr">q</code> (short for <em>query
            selector</em>) to refer to an element in the current context (<span
            class="TODO">TODO: check the exact context of the querySelector
            call</span>); note that using
            <code>#</code> for id may not work, so it is safer to use
            <code>ref</code> below in that situation;</li>
            <li><code class="attr">ref</code> to refer to the id of an element
            in the current document;</li>
            <li><code class="attr">href</code> to refer to a component from an
            XML file located at a given URL.</li>
          </ul>
          <p>Additional attributes (besides <code class="attr">id</code>) and
          contents of the <code>use</code> elements are passed to the
          instantiated component view during rendering as described below.</p>
        </section>

        <section id="manual.elements.view">
          <h4>The view, content and target elements</h4>
          <p>The <code class="node">view</code> element contains foreign
          elements (<em>e.g.</em>, HTML, SVG, &amp;c.) and text nodes describing
          the actual rendering of a component. <code>view</code> may also
          include <code>use</code>, <code>target</code> and <code>content</code>
          elements (other Dumber elements are silently ignored). Additionally,
          <code>use</code> and <code>target</code> elements outside of a
          <code>view</code> element are also rendered as siblings of the
          children of the <code>view</code> elements.</p>
          <p>When a component is rendered, the contents of the view are copied
          as is (minus id attributes as discussed above) into the target
          element. <code>use</code> elements allow to include Dumber components
          inside another component. The <code class="node">content</code> allows
          to customize the rendering of an element by replacing this element
          with the contents of the original <code>use</code>. The
          <code>content</code> element may have content of its own, which is the
          default content that gets rendered when the <code>use</code> has no
          content.</p>
          <p>Similarly, attributes of the <code>use</code> elements are added to
          the top-level elements that get rendered; this allows for instance to
          change the class of an element to alter its rendering.</p>
          <p>Additionally, the <code class="node">target</code> element allows
          to target a specific node for rendering. For instance, it may be used
          to add a <code>style</code> element to the <code>head</code> of an
          HTML target document, or a new definition in the <code>use</code>
          element of an SVG document. The target element is selected through the
          <code class="attr">q</code> or <code class="attr">ref</code>, using a
          query selector (resp. an id) in the <em>target</em> document to
          specify the target. Another optional attribute of <code>target</code>
          is the flag <code class="attr">once</code>, which when set to the
          value <code>true</code> means that the content of the element are
          rendered exactly <em>once</em> to avoid duplicating the content.</p>
        </section>

        <section id="manual.elements.script">
          <h4>The component instance object and the script element</h4>
          <p>Before rendering, a component gets <em>instantiated</em>, which
          creates a new Javascript object acting as the <em>component
          instance</em> of this component. A component instance has the
          following methods and properties:</p>
          <ul>
            <li><code class="def">init(use, component)</code> initializes the
            component after it was created. <code class="param">use</code> is
            the <code>use</code> node instantiating the component, and
            <code class="param">component</code> is the component node being
            instantiated. The component instance has corresponding <code
            class="param">use</code> and <code class="param">component</code>
            properties to access these. The instance is returned.</li>
            <li><code class="prop">views</code> maps the id of the foreign nodes
            inside the view of the component and the actual rendered nodes in
            the target. Nodes that do not have an id are not included.</li>
            <li><code class="prop">uses</code> maps the id of <code>use</code>
            nodes inside the view of the component and the instance that was
            created. Nodes that do not have an id are not included.</li>
            <li><code class="def">instantiated()</code> is called <em>after</em>
            the instance was created and initialized, and right before it will
            be rendered. By default, it does not do anything but can be
            overloaded for component customization.</li>
          </ul>
          <p>The <code class="node">script</code> element contains custom
          Javascript code. This code is executed when the element is added to
          its parent component element <em>and</em> its text content is set
          (<span class="TODO">there will be an <code>href</code> attribute as
          well to load external script files.</span>) The code is executed in
          the context of the parent component element; in Javascript terms,
          <code class="param">this</code> will point to the parent component
          element.</p>
          <p>One use of the <code>script</code> element is to customize the
          behavior of the instances of the component. (Other uses include
          runtime addition of nodes to the view to create complex components
          programmatically rather than exhaustively.) The <em>prototype</em> of
          the component instances may be accessed and modified through the <code
          class="param">_prototype</code> property, so that methods may be added
          or redefined.</p>

        </section>

        <section id="manual.nodes.watch">
          <h4>The watch, get and set nodes</h4>
        </section>

      </section>

      <section id="manual.instances">
        <h3>Component and watch instances</h3>
        <p>Before a component can be rendered, it must be instantiated. Many
        instances of the same component may be created and rendered
        independently, maintaining their own state.</p>
      </section>

      <section id="manual.render-tree">
        <h3>Rendering a Dumber tree</h3>
        <p>A self-contained Dumber application tree can be rendered into any
        host document by simply creating a context with the host document as
        target, populating the tree, and having a <code>use</code> element as a
        child of the root element pointing to the main application component.
        Here is <a href="tests/hello.html">a simple HTML "Hello, world!"
        example</a> being rendered in the body of the host document:</p>
        <pre class="sample">var context = dumber.create_context(document.body);
context.appendChild(
  context.$("component",
    context.$("view",
      context.$("html:p", "Hello, world!"))));
context.appendChild(context.$("use", { q: "component" }));</pre>
      </section>

      <section id="manual.render-component">
        <h3>Rendering a Dumber component in a document</h3>
        <p>Another use case is to render individual components into an existing
        document. The difference is that we render directly a component element
        into the given target, using the <code
          class="def">_render_in(target)</code> where <code
          class="param">target</code> is the parent DOM node where the content
        will be rendered. For example, to <a href="tests/insert.html">render a
        component in a <code>div</code> element</a> with the id <code>here</code>:</p>
        <pre class="sample">var context = dumber.create_context();
context.appendChild(
  context.$("component",
    context.$("view",
      context.$("html:p.dumber", "But this is a Dumber component!"))));
context.querySelector("component")
  ._render_in(document.getElementById("here"));</pre>
        <p><code>_render_in()</code> returns the component instance that was
        created. A ghost <code>use</code> node was also created for
        implementation purpose but not inserted in the context tree (which
        remains unmodified, as it should be) but this behavior should not be
        relied on. The instance can then be unrenderd by setting its
        <code>target</code> to null or undefined.</p>
      </section>

      <section id="manual.load-xml">
        <h3>Loading Dumber components from XML files</h3>
        <p>Real-size applications and components reside in XML files rather than
        Javascript. Loading a component from XML is as simple as creating a new
        <code class="node">use</code> element with an <code
          class="attr">href</code> attribute:</p>
        <pre class="sample">var context = dumber.create_context(document.body);
context.appendChild(context.$("use", { href: ... }));</pre>
      </section>

    </section>

    <aside class="g4">

      <section id="demos">
        <h2>Demos</h2>
        <ol>
          <li><a href="lib/run.html?href=../apps/arrows.xml">SVG Arrows</a></li>
          <li><a
            href="lib/run.html?href=../apps/calculator.xml">Calculator</a></li>
        </ol>
      </section>

      <section id="library">
        <h2>Library</h2>
        <ul>
          <li><a href="lib/run.html">Simple runtime</a>: a virtual <code
            class="node">use</code> element; specify a <code
            class="attr">href</code> paremeter to load a Dumber XML file
          (<em>e.g.</em>, <a href="lib/run.html?href=../tests/hello.xml">Hello,
            world</a>)</li>
          <li><span class="TODO"><a href="lib/button.xml">Button
              component</a></span></li>
          <li><span class="TODO"><a href="tests/color-picker.html">Color
              picker</a></span></li>
          <li><span class="TODO"><a href="tests/audio.html">Audio
              component</a></span></li>
        </ul>
      </section>

      <section id="tests">
        <h2>Tests</h2>
        <ol>
          <li><a href="tests/hello.svg">Hello, world!</a>: display the text
          "Hello, world!" in SVG</li>
          <li><a href="tests/hello.html">Hello, world!</a>: display the text
          "Hello, world!" in HTML</li>
          <li><a href="tests/hello_load.html">Hello, world!</a>: display the
          text "Hello, world!" in HTML; loaded from an XML document.</li>
          <li><a href="tests/disappearer.html">Disappearer</a>: same as above
          but the content is immediately removed so nothing is displayed.</li>
          <li><a href="tests/insert.html">Insert</a>: insert a Dumber node in an
          existing document.</li>
          <li><a href="tests/disappearer.html">Unrender</a>: same as above but
          the content is immediately unrendered.</li>
          <li><a href="tests/title.html">Title setting and updating</a>: the
          title bar should read "Newest title".</li>
          <li><a href="lib/run.html?href=../tests/order.xml">Order of
            definition</a> does not matter as long a component is referred to
          in the same loading context.</li>
          <li><a href="tests/use.html">Nested use modified at runtime</a>:
          display A, B, C followed by - - - with 2 horizontal lines under each
          and = = = between the horizontal lines</li>
          <li><a href="tests/set_attr.html">Setting attributes at runtime</a>:
          the letter A should become red.</li>
          <li><a href="tests/add.html">Adding and removing components</a>:
          display 5 paragraphs: "This is a p.", "This is a q.", "Followed by a
          p.", "This one is added after rendering.", "Followed by a p."</li>
          <li><a href="tests/calculator.html">Calculator (inactive buttons)</a>:
          display a calculator and its buttons</li>
          <li><a href="tests/timer.html">Timer component</a>: timer (script and
          properties)</li>
          <li><a href="tests/button.html">Button component</a>: display three
          buttons "OK", "Cancel", "Retry"; generate an alert when clicked.</li>
          <li><a href="tests/button_style.html">Button with style</a>: same but
          OK is bold and Cancel is semi-transparent.</li>
          <li><a href="tests/lib.html">Loading components from the
            library</a></li>
          <li><a href="lib/run.html?href=../tests/lib.xml">Loading components
            from the library</a>: from an XML file.</li>
          <li><a href="tests/load-order.html">Ordering of components</a>: when
          some need to be loaded</li>
          <li><a href="lib/run.html?href=../tests/load-order.xml">Ordering of
            components</a>: when some need to be loaded (from XML)</li>
          <li><a href="lib/run.html?href=../tests/watch-property.xml">Watch a
            property</a></li>
          <li><a href="lib/run.html?href=../tests/watch-transform.xml">Watch a
            property</a> with a transform (roman numbers)</li>
          <li><a href="lib/run.html?href=../tests/watch-xy.xml">Watch a
            property and set a property</a> creating a simple chain
          reaction.</li>
          <li><a href="lib/run.html?href=../tests/watch-xyz.xml">Watch a
            property and set a cascade</a> of properties.</li>
          <li><a href="lib/run.html?href=../tests/watch-loop.xml">Watch a
            property and set a cascade</a> with a loop; bug when setting
          y/z?</li>
          <li><a href="lib/run.html?href=../tests/textfield.xml">Text
            fields</a></li>
        </ol>
      </section>

    </aside>

    <div class="clear"></div>

    <footer id="copyright">Copyright © 2011, 2012,
      <a href="http://www.igel.co.jp/">IGEL Co., Ltd.</a></footer>

  </body>
</html>

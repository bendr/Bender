<!DOCTYPE html>
<html lang="en">
  <head>
    <title>The Bender Data Model (v0.9, February 2014)</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="doc.css">
  </head>
  <body>
    <h1>The Bender Data Model</h1>
    <p>Version 0.9, February 2014</p>
    <p>See also <a href="processing-model.html">the Bender Processing Model</a>
    and <a href="runtime.html">the Bender Runtime</a> for
    reference.</p>

    <h2>Preliminaries</h2>
    <p>We use a loose notation to describe the data and processing model of
    Bender in terms of objects and prototype, and an implied standard library
    for processing lists, managing DOM elements, &amp;c.</p>
    <ul>
      <li>The data model is defined in terms of <em>Objects</em> and
      <em>data</em>. <code>Object</code>s are defined by their
      <em>properties</em>. A property has a name and a value, which may be any
      <code>data</code>: a boolean, a number, a string, a number, an
      <code>Object</code>, or the undefined value.</li>
      <li>The binary operator <code>is-a</code> checks if the Object on the
      left-hand side was created from the object on the right-hand side.</li>
      <li>A <em>Function</em> is a callable <code>Object</code>. We use lambda
      notation for anonymous functions. The pseudo-code used is a simple
      expression-based language with a liberal syntax that allows side
      effects (functions may not return any value) and mutation of data
      structures.</li>
      <li><em>O</em> <code>&lt;</code> <em>P</em> means that the object
      <em>O</em> is <em>created</em> from the object <em>P</em>. <em>O</em>
      inherits all of the properties of <em>P</em>, along with their values.
      <em>O</em> may have additional properties, and may override any property
      of <em>P</em>.</li>
      <li><em>O</em><code>.</code><em>x</em> means the property <em>x</em> of
      object <em>O</em>.</li>
      <li><code>?</code> means that the property may be undefined.
      The operator <code>defined</code> checks if a value is defined.</li>
      <li><code>*</code> means a list or set of zero or more objects.</li>
      <li><code>+</code> means a list or set of one or more objects.</li>
      <li><code>[]</code> means an empty list.</li>
      <li><code>"..."</code> means a string (which can be considered as a list
      of characters.)</li>
      <li><em>L</em> <code>:</code> <em>x</em> means appending <em>x</em> to the
      list <em>L</em>.</li>
      <li><code>::</code> is the concatenation of two lists.</li>
      <li><code>&lt;-</code> means setting a property of an object on the
      left-hand side to the value on the right-hand side.</li>
      <li><code>=</code> is used for binding (in definitions and
      <code>let</code> forms) or equality testing.</li>
    </ul>


    <h2>Nodes</h2>

    <div class="def" id="Node">
      <p>The Bender data model deals with two kinds of tree structures: trees
      of <em>components</em>, defining the high-level structure of a Bender
      application; and trees of <em>elements</em>, defining the contents and
      layout of a given component. Together, these trees define a <em>component
        graph</em>. Both trees are defined by tree <code>Node</code>s.</p>
      <div>
        <pre>Node &lt; Object
  Node?  parent
  Node*  children</pre>
        <ul>
          <li><code>parent</code> is the parent <code>Node</code>, if any, of
          the node. The <em>root</em> of a tree has no <code>parent</code>.</li>
          <li><code>children</code> is the list of child <code>Node</code>s of
          the node.</li>
        </ul>
      </div>
    </div>


    <h2>Components</h2>

    <div class="def" id="Component">
      <p>The <code>Component</code> is the basic unit of functionality in
      Bender. Components are defined in terms of other components, both through
      <em>composition</em> (a component may contain child components) and
      <em>inheritance</em> (a component may inherit from a prototype
      component.)</p>
      <p>A <em>top-level component</em> is a <code>Component</code> with no
      <code>parent</code>, <em>i.e.</em>, it is the root of a component tree.
      There is no separate concept of “application” in Bender; a Bender
      application is a component.</p>
      <div>
        <pre>Component &lt; Node
  Component?  prototype
  data*       properties
  View        view
  Watch*      watches</pre>
        <ul>
          <li><code>prototype</code> is the <code>Component</code> that this
          component inherit from, if any. The prototype component must be a
          top-level component. The <em>prototype chain</em> is the sequence of
          <code>Component</code>s formed by the prototype and its prototype
          chain. The prototype chain must not contain any cycle, <em>i.e.</em>,
          a component cannot inherit from itself either directly or
          indirectly.</li>
          <li><code>properties</code> is the list of all property values for
          this component, indexed by their name.<span class="TODO"> All
          properties of a component are “public”. However, having private
          properties would be useful; the list of properties could then be split
          in two, a list of public properties, and a list of private properties.
          The list of public properties would be inherited, while the list of
          private properties would not.</span></li>
          <li><code>view</code> is the root of the view tree of this
          component.</li>
          <li><code>watches</code> is the set of all <code>Watch</code>es of the
          component.</li>
        </ul>
      </div>
    </div>


    <h2>View and elements</h2>

    <p>The <em>view</em> of a <code>Component</code> describes its contents and
    layout as a tree of <code>Element</code>s. These elements describe how a
    component is rendered and which other <code>Component</code>s it
    contains.</p>

    <div class="def" id="Element">
      <p><code>Element</code>s are <code>Node</code>s describing the view of a
      <code>Component</code>.</p>
      <div>
        <pre>Element &lt; Node
  View  view</pre>
        <ul>
          <li><code>view</code> is the closest <code>View</code> ancestor
          element of the <code>Element</code>.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="View">
      <p>The <code>View</code> element is a container for the view of a
      component.</p>
      <div>
        <pre>View &lt; Element
  Component  component
  boolean    default</pre>
        <ul>
          <li><code>component</code> is the <code>Component</code> that this is
          the view of.</li>
          <li><code>default</code> is a flag that distinguishes the absence of
          a view from an empty view. If this flag is set, then there should be
          zero <code>children</code>. An <em>empty</em> view is a view with
          zero <code>children</code> but with the <code>default</code> flag
          unset.<span class="TODO"> Instead of a flag, a
            <code>DefaultView</code> could be used instead?</span></li>
          <li><strong>Note</strong>: for a <code>View</code>, the
          <code>view</code> property is itself.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="Content">
      <p>The <code>Content</code> element provides an extension point for the
      view of derived components. Its children define default content.</p>
      <div>
        <pre>Content &lt; Element</pre>
      </div>
    </div>

    <div class="def" id="DOMElement">
      <p>The <code>DOMElement</code> element represents a foreign element
      (<em>i.e.</em>, not a Bender element.) Its properties map to properties of
      DOM elements.</p>
      <div>
        <pre>DOMElement &lt; Element
  string  namespace-uri
  string  local-name
  data*   attributess</pre>
        <ul>
          <li><code>namespace-uri</code> is the namespace URI of the DOM
          element.</li>
          <li><code>local-name</code> is the local name of the DOM element.</li>
          <li><code>attributes</code> is a list of attribute values of the DOM
          element, indexed first by namespace URI, then by local name.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="Attribute">
      <p>The <code>Attribute</code> element represents an attribute of its
      parent element, similarly to a DOM attribute node.</p>
      <div>
        <pre>Attribute &lt; Element
  string  namespace-uri
  string  local-name</pre>
        <ul>
          <li><code>namespace-uri</code> is the namespace URI of the
          attribute.</li>
          <li><code>local-name</code> is the local name of the attribute.</li>
          <li><strong>Note</strong>: the value of the attribute is defined by
          the concatenation of the <code>text</code> of its <code>Text</code>
          child elements. Other children are ignored.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="Text">
      <p>The <code>Text</code> element represents a text node, similarly to a
      DOM text node or CDATA section.</p>
      <div>
        <pre>Text &lt; Element
  string  text</pre>
        <ul>
          <li><code>text</code> is the text content of the element.</li>
          <li><strong>Note</strong>: a <code>Text</code> element should not
          have children.</li>
        </ul>
      </div>
    </div>


    <h2>Watches</h2>
    <p>Watches describe the behavior of a component. A <em>watch</em>
    generalizes the concept of the <em>event listener</em> by allowing
    components to listen to event notifications from rendered elements
    (<em>e.g.</em>, DOM events), and event notifications and property changes
    from <code>Component</code>s; and associating these occurrences with
    corresponding actions, such as generating new event notifications, setting
    new values for properties, or mutating a component.</p>

    <h3>Watch</h3>

    <div class="def" id="Watch">
      <p>A <code>Watch</code> has <em>inputs</em> (incoming event notifications
      or property changes) and <em>outputs</em> (outgoing event notifications,
      property changes, or mutations.)</p>
      <div>
        <pre>Watch &lt; Object
  Component  component
  Get*       gets
  Set*       sets</pre>
        <ul>
          <li><code>component</code> is the owner <code>Component</code> of
          this watch.</li>
          <li><code>gets</code> is the set of <code>Get</code>s (inputs) of this
          watch.</li>
          <li><code>sets</code> is the set of <code>Set</code>s (outputs) of
          this watch.</li>
        </ul>
      </div>
    </div>


    <h3>Adapters</h3>

    <div class="def" id="Adapter">
      <p>An <code>Adapter</code> filters and transforms an input value into an
      output value, with an optional delay, in the context of a <em>target</em>
      <code>Node</code>.</p>
      <div>
        <pre>Adapter &lt; Object
  Watch     watch
  Node      target
  boolean   static = false
  Function  value = λx x
  Function  match = λx true
  number?   delay</pre>
        <ul>
          <li><code>watch</code> is the owner <code>Watch</code> of the
          adapter.</li>
          <li><code>target</code> is the <em>static target</em> of this adapter.
          The role of the target depends on the specific
          <code>Adapter</code>.</li>
          <li><code>static</code> is a flag that defines whether the
          <code>Adapter</code> applies to a static target (when set) or a
          <em>runtime target</em> (otherwise), meaning any <code>Node</code>
          that is, or derives from, the static target <code>Node</code>.</li>
          <li><code>value</code> is a function transforming an input value into
          an output value. The default is the identity function, which returns
          its input. It may return any <code>data</code>.</li>
          <li><code>match</code> is a predicate that takes an input value and
          returns a boolean value that is true if and only if the input is
          <em>valid</em> for this adapter. If an input is invalid, no value is
          output by the adapter. The default is a function that returns true for
          any input, treating any input value as valid.</li>
          <li><code>delay</code> is the delay before an output value is
          returned. When <code>delay</code> is undefined, there is no delay, and
          the output value is returned synchronously. When <code>delay</code> is
          0, then the output value is returned as soon as possible, but
          asynchronously. When <code>delay</code> is larger than 0, then this is
          the delay in milliseconds before which an output value is
          returned.</li>
        </ul>
      </div>
    </div>

    <h3>Get</h3>

    <div class="def" id="Get">
      <p>A <code>Get</code> is a watch input adapter. There are two different
      kinds of input: a <em>property input</em>, or an <em>event input</em>.</p>
      <div>
        <pre>Get &lt; Adapter</pre>
      </div>
    </div>

    <div class="def" id="GetProperty">
      <p>A <code>GetProperty</code> is a property input.</p>
      <div>
        <pre>GetProperty &lt; Get
  string  name</pre>
        <ul>
          <li><code>name</code> is the name of the property that is
          monitored.</li>
          <li><strong>Note</strong>: the <code>target</code> of a
          <code>GetProperty</code> must be a <code>Component</code> for which
          the property is defined, <em>i.e.</em>, there must be a entry for
          <code>name</code> in <code>target.properties</code>.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="GetEvent">
      <p>A <code>GetEvent</code> is an event input.</p>
      <div>
        <pre>GetEvent &lt; Get
  string  type</pre>
        <ul>
          <li><code>type</code> is the type of the event that is being listened
          to.</li>
          <li><strong>Note</strong>: the <code>target</code> of a
          <code>GetEvent</code> must be a <code>Component</code> or a
          <code>DOMElement</code>. <code>type</code> is then interpreted as the
          type of a Bender or DOM event (respectively.)</li>
        </ul>
      </div>
    </div>


    <h3>Set</h3>

    <div class="def" id="Set">
      <p>A <code>Set</code> is a watch output. There are five different kinds
      of output: a <em>plain output</em>, a <em>component property output</em>,
      a <em>node proprety output</em>, an <em>attribute output</em>, or an
      <em>event output</em>.</p>
      <div>
        <pre>Set &lt; Adapter</pre>
        <ul>
          <li><strong>Note</strong>: this is a <em>plain</em> output and is used
          for side effects only, such as mutating the contents of a
          component, or having effects outside of the scope of Bender.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="SetProperty">
      <p>A <code>SetProperty</code> is a <code>Component</code> property
      output.</p>
      <div>
        <pre>SetProperty &lt; Set
  string  name</pre>
        <ul>
          <li><code>name</code> is the name of the property to be set.</li>
          <li><strong>Note</strong>: the <code>target</code> of a
          <code>SetProperty</code> must be a <code>Component</code> for which
          the property is defined, <em>i.e.</em>, there must be a entry for
          <code>name</code> in <code>target.properties</code>.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="SetNodeProperty">
      <p>A <code>SetNodeProperty</code> is a <code>Node</code> property
      output.</p>
      <div>
        <pre>SetNodeProperty &lt; Set
  string  name</pre>
        <ul>
          <li><code>name</code> is the name of the property to be set on the
          target <code>Node</code>.
        </ul>
      </div>
    </div>

    <div class="def" id="SetAttribute">
      <p>A <code>SetAttribute</code> is an attribute output.</p>
      <div>
        <pre>SetAttribute &lt; Set
  string?  ns
  string   name</pre>
        <ul>
          <li><code>ns</code> is the namespace URI of the attribute to
          set.</li>
          <li><code>name</code> is the local name of the attribute to set.</li>
          <li><strong>Note</strong>: the <code>target</code> must be a
          <code>DOMElement</code>.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="SetEvent">
      <p>A <code>SetEvent</code> is an event output.</p>
      <div>
        <pre>SetEvent &lt; Set
  string  type</pre>
        <ul>
          <li><code>type</code> is the type of the event to generate:
          <ul>
            <li>if the <code>target</code> is a <code>DOMElement</code>, then a
            DOM event is synthesized;
            <li>otherwise, the <code>target</code> must be a
            <code>Component</code>, and a Bender event notification is
            generated.</li>
        </ul>
      </div>
    </div>

    <h3 id="example">Example</h3>
    <p>Consider a non-trivial component (called <em>Panel</em>) <a
      href="runtime.html#s11n">defined in XML</a> as follows:</p>

    <div class="def" id="Panel">
      <div>
        <pre>&lt;component xmlns="http://bender.igel.co.jp" name="Panel"&gt;
  &lt;property name="n" value="0"/&gt;
  &lt;view xmlns:html="http://www.w3.org/1999/xhtml"&gt;
    &lt;html:div&gt;
      &lt;text name="text-n"/&gt;
      &lt;component href="button.xml" name="Plus" label="+"/&gt;
      &lt;component href="button.xml" name="Minus" label="—"/&gt;
    &lt;/html:div&gt;
  &lt;/view&gt;
  &lt;watch&gt; <span class="watch">1</span>
    &lt;get select="Plus" event="pushed"/&gt;
    &lt;set property="n" value="`n + 1"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">2</span>
    &lt;get select="Minus" event="pushed"/&gt;
    &lt;set property="n" value="`n - 1"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">3</span>
    &lt;get property="n"/&gt;
    &lt;set select="text-n"/&gt;
    &lt;set select="Minus" property="enabled" value="$in &amp;gt; 0"/&gt;
  &lt;/watch&gt;
&lt;/component&gt;</pre>
        <ul>
          <li><code>Panel</code> has a property named <code>n</code>, as
          specified by the <code>name</code> attribute, with an initial value of
          0, as specified by the <code>value</code> attribute.</li>
          <li><code>Panel</code> has a <code>View</code> with a
          <code>DOMElement</code> child (a HTML <code>div</code> element), with
          three children. The first is a <code>Text</code> child with the name
          <code>text-n</code>, as specified by the <code>id</code>
          attribute.</li>
          <li><code>Panel</code> also has two child components with the name
          <code>Plus</code> and <code>Minus</code> (as specified by the
          <code>id</code> attribute), both inheriting from the
          <code>Button</code> component shown below (as specified by the
          <code>href</code> attribute), with a different initial value for the
          <code>label</code> property (as specified by the <code>label</code>
          attribute), and a default view.</li>
          <li>The <code>Watch</code> <span class="watch">1</span> has one
          input and one output:
          <ul>
            <li>the input is a <code>GetEvent</code>. The <code>target</code> is
            the <code>Plus</code> <code>Component</code>, as specified by the
            <code>select</code> attribute. The input is listening to a Bender
            event of type <code>pushed</code>;</li>
            <li>the output is a <code>SetProperty</code>. The target property is
            the <code>n</code> property of the <code>Panel</code> component, as
            specified by the <code>property</code> attribute. The output value
            is one plus the value of <code>n</code>, as specified by the
            <code>value</code> element.</li>
          </ul>
          (The effect of this watch is to increment the value of <code>n</code>
          when the <code>Plus</code> button is pushed.)</li>
          <li>The <code>Watch</code> <span class="watch">2</span> is similar,
          with the input target being the <code>Minus</code>
          <code>Component</code>, and the output value being 1 minus the value
          of <code>n</code>.  The effect of this watch is to decrement the value
          of <code>n</code> when the <code>Plus</code> button is pushed.</li>
          <li>The <code>Watch</code> <span class="watch">3</span> has one input
          and two outputs:
          <ul>
            <li>the input is a <code>GetProperty</code>. The target property is
            the <code>n</code> property of <code>Panel</code>.</li>
            <li>the first output is a <code>SetNodeProperty</code>. The target
            is the <code>text-n</code> <code>Text</code> element; by default,
            the property to set is <code>text</code>;</li>
            <li>the second output is a <code>SetProperty</code>. The target
            property is the <code>enabled</code> property of the
            <code>Minus</code> <code>Component</code>. The output value is
            a boolean value that is true if and only if the input value is
            greater than 0. (Because this is XML, the <code>&gt;</code>
            character must be escaped.)</li>
          </ul>
          </li>
        </ul>
      </div>
    </div>

    <div class="def" id="Button">
      <p>This second component is the <code>Button</code> prototype of both
      <code>Plus</code> and <code>Minus</code> buttons above.</p>
      <div>
        <pre>&lt;component xmlns="http://bender.igel.co.jp" name="Button"&gt;
  &lt;property name="label" as="string" value="Label"&gt;
  &lt;property name="enabled" value="true"&gt;
  &lt;property name="down" value="false"&gt;
  &lt;view xmlns:html="http://www.w3.org/1999/xhtml"&gt;
    &lt;html:div name="frame"&gt;
      &lt;content&gt;
        &lt;text name="text-label"/&gt;
      &lt;/content&gt;
    &lt;/html:div&gt;
  &lt;/view&gt;
  &lt;watch&gt; <span class="watch">4</span>
    &lt;get property="label"/&gt;
    &lt;set select="text-label"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">5</span>
    &lt;get select="frame" event="mousedown"/&gt;
    &lt;set property="down" match="`enabled" value="true"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">6</span>
    &lt;get select="frame" event="mouseup"/&gt;
    &lt;set event="pushed" match="`down"/&gt;
    &lt;set property="down" value="false"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">7</span>
    &lt;get property="down"/&gt;
    &lt;set select="frame" attribute="class" value="$in ? 'down' : ''/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">8</span>
    &lt;get property="enabled"/&gt;
    &lt;set select="frame" attribute="class" value="$in ? '' : 'disabled'/&gt;
  &lt;/watch&gt;
&lt;/component&gt;</pre>
        <ul>
          <li><code>Button</code> has a property named <code>label</code> with
          initial value <code>"Label"</code>. The <code>as</code> attribute
          specifies that the value should be interpreted as a character
          string.</li>
          <li><code>Button</code> has a property named <code>enabled</code> with
          initial value <code>true</code>.</li>
          <li><code>Button</code> has a property named <code>down</code> with
          initial value <code>false</code>.</li>
          <li><code>Button</code> has a <code>View</code> containing a
            <code>DOMElement</code> (a HTML <code>div</code> element with the
            name <code>frame</code>), containing a <code>Content</code> element,
            containing a <code>Text</code> element with the name
            <code>text-label</code>.</li>
          <li><code>Button</code> has no child <code>Component</code>.</li>
          <li>The <code>Watch</code> <span class="watch">4</span> has one
          input and one output:
          <ul>
            <li>the input is a <code>GetProperty</code>. The <code>target</code>
            is the <code>Button</code> <code>Component</code>, and the
            <code>property</code> is the <code>label</code> property of
            <code>Button</code>;</li>
            <li>the output is a <code>SetNodeProperty</code>. The target
            <code>Node</code> is the <code>text-label</code> <code>Text</code>
            element, and the property to set defaults to <code>text</code> in
            the absence of a <code>property</code> attribute.</li>
          </ul>
          The effect of this watch is to show the value of the
          <code>label</code> string in the button.</li>
          <li>The <code>Watch</code> <span class="watch">5</span> has one
          input and one output:
          <ul>
            <li>the input is a <code>GetEvent</code>. The <code>target</code>
            is the <code>frame</code> <code>DOMElement</code>, and the event
            <code>type</code> is <code>mousedown</code>;
            <li>the output is a <code>SetProperty</code>. The target is the
            <code>Button</code> component, and the <code>property</code> is the
            <code>down</code> property of <code>Button</code>. The
            <code>value</code> is a function that returns true. The
            <code>match</code> function returns true if and only if the
            <code>enabled</code> property of the <code>target</code> is
            true.</li>
          </ul>
          The effect of this watch is to set the <code>down</code> property of
          the button to true when the mouse button is pressed, but only when
          the button is enabled.</li>
          <li>The <code>Watch</code> <span class="watch">6</span> has one input
          and two outputs:
          <ul>
            <li>the input is a <code>GetEvent</code>. The <code>target</code>
            is the <code>frame</code> <code>DOMElement</code>, and the event
            <code>type</code> is <code>mouseup</code>;
            <li>the first output is a <code>SetEvent</code>. The target is
            the <code>Button</code> <code>Component</code>, and the
            <code>type</code> of the event is <code>pushed</code>. The
            <code>match</code> function of the output is a function that returns
            true if and only if <code>down</code> property of the
            <code>target</code> is true;</li>
            <li>the second output is a <code>SetProperty</code>. The target is
            the <code>Button</code> component, and the <code>property</code> is
            the <code>down</code> property of <code>Button</code>. The
            <code>value</code> is a function that returns false.</li>
          </ul>
          The effect of this watch is to set the <code>down</code> property of
          the button back to false when the mouse button is released, and
          dispatch a pushed event if the <code>down</code> property was indeed
          true (<em>i.e.</em> the mouse was pressed inside the button.)</li>
          </li>
          <li>The <code>Watch</code> <span class="watch">7</span> has one input
          and one output:
          <ul>
            <li>the input is a <code>GetProperty</code>. The <code>target</code>
            is a the <code>Button</code> <code>Component</code>, and the
            <code>property</code> is the <code>down</code> property;</li>
            <li>the output is a <code>SetAttribute</code>. The
            <code>target</code> is the <code>frame</code>
            <code>DOMElement</code>, the attribute to set has no namespace and
            the <code>class</code> name (<em>i.e.</em>, the HTML
            <code>class</code> attribute of the HTML <code>div</code> element),
            and the value is a function that returns the string
            <code>"down"</code> if its input is true, and the empty string
            otherwise.</li>
          </ul>
          The effect of this watch is to set the class of the frame element to
          <code>down</code> if and only if the button is down.
          </li>
          <li>The <code>Watch</code> <span class="watch">8</span> has one input
          and one output:
          <ul>
            <li>the input is a <code>GetProperty</code>. The <code>target</code>
            is a the <code>Button</code> <code>Component</code>, and the
            <code>property</code> is the <code>enabled</code> property;</li>
            <li>the output is a <code>SetAttribute</code>. The
            <code>target</code> is the <code>frame</code>
            <code>DOMElement</code>, the attribute to set has no namespace and
            the <code>class</code> name (<em>i.e.</em>, the HTML
            <code>class</code> attribute of the HTML <code>div</code> element),
            and the value is a function that returns the string
            <code>"disabled"</code> if its input is false, and the empty string
            otherwise.</li>
          </ul>
          The effect of this watch is to set the class of the frame element to
          <code>disabled</code> if and only if the button is <em>not</em>
          enabled.
          </li>
        </ul>
      </div>
    </div>

    <p>The figure below shows the component graph of <code>Panel</code>. Black
    arrows are parent/child relationships. Pink arrows point to a prototype.
    Blue arrows point from a <code>Component</code> to its <code>View</code>.
    <code>Component</code> nodes are shown as ellipses, while view
    <code>Element</code>s are shown as boxes. The graph of a top-level component
    is enclosed within a green box.</p>

    <figure>
      <img src="fig/panel.svg">
      <figcaption>Component and view tree of <code>Panel</code>.</figcaption>
    </figure>

    <p>This example is used again to illustrate <a
      href="processing-model.html">the processing model of Bender</a>.</p>

  </body>
</html>

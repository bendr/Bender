<!DOCTYPE html>
<html lang="en">
  <head>
    <title>The Bender Processing Model (v0.9, February 2014)</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="doc.css">
  </head>
  <body>
    <h1>The Bender Processing Model</h1>
    <p>Version 0.9, February 2014</p>
    <p>See also <a href="data-model.html">the Bender Data Model</a> and <a
      href="xml-api.html">the Bender XML and Javascript API</a> for reference.</p>


    <h2>Informal Overview</h2>
    <p>A Bender application is defined by a component, its children, and their
    prototype. The graph of all components that are part of the definition of an
    application is called the <em>component graph</em> of the application.
    At runtime, the component graph is augmented with copies of views and
    components; the result is the <em>runtime graph</em>.</p>
    <p>Copies of nodes are necessary in when several components have a common
    prototype, as child components of a shared prototype component need copying
    in order to maintain their own state independently of each other. The views
    of the runtime graph are then rendered by the user agent, and a <em>watch
      graph</em> is also constructed.</p>
    <p>The watch graph is a compilation of all the watches in the component
    graph. The main idea behind the watch graph is to create edges between
    vertices, where a vertex represents the value of a property or the
    occurrence of an event, and edges the changes that happen in between. When
    a value changes or an event occurs, that value is propagated through the
    edges and vertices of the graph, having effects on the running
    application.</p>


    <h2>Running a Bender Application in a User Agent</h2>
    <p>Running a Bender application in a user agent, such as a Web browser, is
    rendering the <code>Component</code> in a target DOM element.</p>
    <pre class="code">run-application(Component C, DOM element T) =
  let G = new WatchGraph in
    do
      render-subgraph(C, G)
      render-component(C, T)
      init-properties(C, G)</pre>


    <h2>Constructing the Watch Graph</h2>

    <div class="def" id="WatchGraph">
      <p>The <code>WatchGraph</code> is defined as an ordered list of directed
      <em>edges</em> between <em>vertices</em>. Edges are kept sorted in
      <em>topological order</em> so that data flow is consistent and
      predictable. This also means that the graph should be acyclic; however,
      through the use of <em>delayed</em> edges (see below), cycles may be
      introduced under certain conditions.</p>
      <div>
        <pre>WatchGraph &lt; Object
  Vertex+  vertices
  Vertex   vortex
  Edges*   edges</pre>
        <ul>
          <li><code>vertices</code> is the unordered list of vertices. It always
          contains at least one <code>Vertex</code> (the
          <code>vortex</code>.)</li>
          <li><code>vortex</code> is a <em>sink state</em> of the graph. It
          has no outgoing edge and is a member of <code>vertices</code>.</li>
          <li><code>edges</code> is the ordered list of edges between vertices
          in the graph.</li>
        </ul>
      </div>
    </div>


    <h3>Vertices</h3>

    <div class="def" id="Vertex">
      <p>A vertex in the <code>WatchGraph</code>.</p>
      <div>
        <pre>Vertex &lt; Object
  Edge*  incoming
  Edge*  outgoing</pre>
        <ul>
          <li><code>incoming</code> is the unordered list of incoming
          <code>Edge</code>s, <em>i.e.</em> edges that have this vertex as
          destination.</li>
          <li><code>outgoing</code> is the unordered list of outgoing
          <code>Edge</code>s, <em>i.e.</em> edges that have this vertex as
          source.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="WatchVertex">
      <p>A <code>WatchVertex</code> is a vertex representing a
      <code>Watch</code> of a <code>Component</code>.</p>
      <div>
        <pre>WatchVertex &lt; Vertex
  Watch  watch</pre>
        <ul>
          <li><code>watch</code> is the <code>Watch</code> for this vertex.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="AdapterVertex">
      <p>An <code>AdapterVertex</code> is a vertex representing a
      <code>Get</code> or <code>Set</code> in a <code>Watch</code>.</p>
      <div>
        <pre>AdapterVertex &lt; Vertex
  Adapter  adapter</pre>
        <ul>
          <li><code>adapter</code> is the <code>Get</code> or <code>Set</code>
          for this vertex.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="PropertyVertex">
      <p>A <code>PropertyVertex</code> is a vertex representing a
      <code>GetProperty</code> or <code>SetProperty</code> in a
      <code>Watch</code>.</p>
      <div>
        <pre>PropertyVertex &lt; AdapterVertex</pre>
        <ul>
          <li><strong>Note</strong>: the <code>Adapter</code> of the vertex
          being either a <code>GetProperty</code> or <code>SetProperty</code>,
          the property associated with this vertex is accessible through
          <code>adapter.property</code>.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="EventVertex">
      <p>An <code>EventVertex</code> is a vertex representing a
      <code>GetEvent</code> or <code>SetEvent</code> in a
      <code>Watch</code>.</p>
      <div>
        <pre>EventVertex &lt; AdapterVertex</pre>
        <ul>
          <li><strong>Note</strong>: the <code>Adapter</code> of the vertex
          being either a <code>GetEvent</code> or <code>SetEvent</code>,
          the type of the event associated with this vertex is accessible
          through <code>adapter.type</code>.</li>
        </ul>
      </div>
    </div>

    <h3>Edges</h3>
    <div class="def" id="Edge">
      <p>An <code>Edge</code> is a directed transition from a <em>source</em> to
      a <em>destination</em> <code>Vertex</code>.</p>
      <div>
        <pre>Edge &lt; Object
  Vertex  source
  Vertex  dest</pre>
        <ul>
          <li><code>source</code> is the source <code>Vertex</code> of the
          edge.</li>
          <li><code>dest</code> is the destination <code>Vertex</code> of the
          edge.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="InheritEdge">
      <p>An <code>InheritEdge</code> is an edge between two vertices
      representing the same property or event. The source of the
      <code>Edge</code> is the <em>prototype vertex</em> of the destination
      <code>Vertex</code>, and is a vertex for a <code>Component</code> that is
      in the prototype chain of the component of the destination
      <code>Vertex</code>. The purpose of <code>InheritEdge</code>s is to make
      components inherit the behavior of their prototype, while adding behavior
      of their own. Another benefit of these edges is to avoid situations that
      may lead to spurious cycles in the graph.</p>
      <div>
        <pre>InheritEdge &lt; Edge</pre>
      </div>
    </div>

    <div class="def" id="AdapterEdge">
      <p>An <code>AdapterEdge</code> is an <code>Edge</code> rendered from a
      <code>Get</code> or <code>Set</code>.</p>
      <div>
        <pre>AdapterEdge &lt; Object:
  Adapter  adapter</pre>
        <ul>
          <li><code>adapter</code> is the <code>Get</code> or <code>Set</code>
          for this edge.</li>
        </ul>
      </div>
    </div>

    <h3>Rendering the Watch Graph of a Component</h3>
    <p>The sub-graph of a <code>Component</code> <em>C</em> in a
    <code>WatchGraph</code> <em>G</em> is constructed by rendering the sub-graph
    of the prototype <em>C</em>, if any, in <em>G</em>; then rendering vertices
    and edges for every <code>Watch</code> in <em>C</em>; and finally rendering
    the sub-graph of the child components. The component is marked so that its
    sub-graph is rendered only once. This is necessary because a prototype
    component may be shared by several components, which will all require it
    to render its sub-graph.</p>
    <pre class="code">render-subgraph(Component C, WatchGraph G) =
  do
    mark C
    if defined? C.prototype and not marked? C.prototype
      then render-subgraph(C.prototype, G)
    for W in C.Watches
      render-watch(W, G)
    for C’ in C.children
      render-subgraph(C’, G)</pre>

    <p>The sub-graph for a <code>Watch</code> <em>W</em> is rendered by
    creating a new <code>WatchVertex</code> <em>V</em> in <em>G</em>, then an
    <code>AdapterEdge</code> to <em>V</em> for each <code>Get</code> of
    <em>W</em>, and an <code>AdapterEdge</code> from <em>V</em> for every
    <code>Set</code> of <em>W</em>.</p>
    <pre class="code">render-watch(Watch W, Graph G) =
  let V = new WatchVertex(W) in
    do
      G.vertices = G.vertices : V
      for H in W.gets
        let V’ = find-adapter-vertex(H, G) in
          G.edges = G.edges : new AdapterEdge(V’, V, H)
      for S in W.sets
        let V’ = find-adapter-vertex(S, G) in
          G.edges = G.edges : new AdapterEdge(V, V’, S)</pre>


    <p>The source or destination vertex of an <code>AdapterEdge</code> to or
    from a <code>WatchVertex</code> is a <code>PropertyVertex</code>,
    <code>EventVertex</code> or <code>DOMEventVertex</code>, depending on the
    adapter. A vertex may be the source and destination of several edges, so
    it is created the first time that it is needed and added to the graph.
    Subsequent calls to <code>find-adapter-vertex(A, G)</code> will return the
    already created vertex.</p>
    <pre class="code">AdapterVertex find-adapter-vertex(Adapter A, Graph G) =
  let V = find(G.vertices, λV V is-a AdapterVertex &amp; V.adapter == A) in
    if defined? V
      then V
      else
        let V’ = new AdapterVertex(A) in
          do
            G.vertices = G.vertices : V’
            add-inherit-edge(V’, G)
            V’</pre>

    <p>The figure below shows the rendering of watch <span
    class="watch">6</span> of the <code>Button</code> example component (in this
    example, other watches are ignored.) A <code>WatchVertex</code> (square) is
    created, then an <code>AdapterEdge</code> to this vertex is added from a new
    <code>EventVertex</code> (heptagon) for the <code>GetEvent</code>, then two
    <code>AdapterEdge</code>s from the <code>WatchVertex</code> are created for
    the <code>SetProperty</code> to a <code>PropertyVertex</code> (ellipse) for
    the <code>down</code> <code>Property</code>, and another
    <code>AdapterEdge</code> for the <code>SetEvent</code> to an
    <code>EventVertex</code>.</p>

    <pre class="code">&lt;watch&gt; <span class="watch">6</span>
  &lt;get select="@frame" event="mouseup"/&gt;
  &lt;set event="pushed" match="`down"/&gt;
  &lt;set property="down" value="false"/&gt;
&lt;/watch&gt;</pre>

    <figure>
      <img src="fig/graph-watch-6.svg">
      <figcaption>The watch sub-graph for watch <span class="watch">6</span> of
      the <code>Button</code>.</figcaption>
    </figure>

    <p>The figure below shows the addition of the sub-graph for watch <span
    class="watch">7</span>. A new <code>WatchVertex</code> is added, then a new
    <code>AdapterEdge</code> for the <code>GetProperty</code>, reusing the
    <code>PropertyVertex</code> of <code>down</code> as the source vertex.
    Finally, the <code>SetAttribute</code> is rendered as an
    <code>AdapterEdge</code> to the vortex (triangle.)</p>

    <pre class="code">&lt;watch&gt; <span class="watch">7</span>
  &lt;get property="down"/&gt;
  &lt;set select="@frame" attribute="@class" value="$in ? 'down' : ''/&gt;
&lt;/watch&gt;
    </pre>

    <figure>
      <img src="fig/graph-watch-67.svg">
      <figcaption>The watch sub-graph for watches <span class="watch">6</span>
      and <span class="watch">7</span> of the <code>Button</code>.</figcaption>
    </figure>

    <p>If there exists a prototype vertex <em>V’</em> for a vertex <em>V</em>
    (see below), then a new <code>InheritEdge</code> is added between
    <em>V’</em> and <em>V</em>. The outgoing edges of <em>V’</em> are also
    copied to <em>V</em>.</p>
    <pre class="code">add-inherit-edge(AdapterVertex V, Graph G) =
  let V’ = find-prototype-vertex(V, G) in
    if defined? V’ then
      do
        G.edges = G.edges : new InheritEdge(V’, V)
        for E in V’.outgoing
          let E’ = create(E) in
            do
              E’.source = V
              G.edges = G.edges : E’</pre>

    <p><span class="TODO"><code>Vertex? find-prototype-vertex(Graph G,
    Vertex V)</code> finds the prototype vertex <em>V’</em> in <em>G</em> such
    that <em>V</em> and <em>V’</em> share the same property or event, and the
    component of <em>V’</em> is the closes component in the prototype chain of
    <em>V</em> that has such a vertex, if it exists.</p>


    <h3>Edge Sorting</h3>
    <p>Once the graph <em>G</em> is built, its <code>edges</code> are sorted in
    topological order. Starting from vertices that have no outgoing edge (there
    is always at least one such vertex, the <code>vortex</code>), incoming edges
    are pushed at the end of the list of edges and removed from the list of
    outgoing edges their source vertex. The process repeats with the vertices
    which do not have any outgoing edge anymore. If there were no cycles in the
    graph, all edges and vertices are processed, otherwise an error is raised
    (although cycles may be broken when they include delayed edges, see
    below.)</p>
    <p>The list of incoming edges of a vertex is not ordered, 
    <p>When pushing a list incoming edges,  </p>
    <pre class="code"><span class="TODO">Edge* sort-edges(Edge *) = ...</span></pre>


    <h3>Example</h3>

    <p>To illustrate the rendering of the watch graph, review the
    <code>Panel</code> component from the <a href="data-model.html#example">Data
    Model</a> description.</p>
    <div class="def" id="Panel">
      <div>
        <pre>&lt;component xmlns="http://bender.igel.co.jp" id="Panel"&gt;
  &lt;property name="n" value="0"/&gt;
  &lt;view xmlns:html="http://www.w3.org/1999/xhtml"&gt;
    &lt;html:div&gt;
      &lt;text id="text-n"/&gt;
      &lt;component href="button.xml" id="Plus" label="+"/&gt;
      &lt;component href="button.xml" id="Minus" label="—"/&gt;
    &lt;/html:div&gt;
  &lt;/view&gt;
  &lt;watch&gt; <span class="watch">1</span>
    &lt;get select="@Plus" event="pushed"/&gt;
    &lt;set property="n" value="`n + 1"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">2</span>
    &lt;get select="@Minus" event="pushed"/&gt;
    &lt;set property="n" value="`n - 1"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">3</span>
    &lt;get property="n"/&gt;
    &lt;set select="@text-n"/&gt;
    &lt;set select="@Minus" property="enabled" value="$in &amp;gt; 0"/&gt;
  &lt;/watch&gt;
&lt;/component&gt;</pre>
      </div>
    </div>

    <div class="def" id="Button">
      <p>This is the <code>Button</code> component.</p>
      <div>
        <pre>&lt;component xmlns="http://bender.igel.co.jp" id="Button"&gt;
  &lt;property name="label" as="string" value="Label"&gt;
  &lt;property name="enabled" value="true"&gt;
  &lt;property name="pushed" value="false"&gt;
  &lt;view xmlns:html="http://www.w3.org/1999/xhtml"&gt;
    &lt;html:div id="frame"&gt;
      &lt;content&gt;
        &lt;text id="text-label"/&gt;
      &lt;/content&gt;
    &lt;/html:div&gt;
  &lt;/view&gt;
  &lt;watch&gt; <span class="watch">4</span>
    &lt;get property="label"/&gt;
    &lt;set select="@text-label"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">5</span>
    &lt;get select="@frame" event="mousedown"/&gt;
    &lt;set property="down" match="`enabled" value="true"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">6</span>
    &lt;get select="@frame" event="mouseup"/&gt;
    &lt;set event="pushed" match="`down"/&gt;
    &lt;set property="down" value="false"/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">7</span>
    &lt;get property="down"/&gt;
    &lt;set select="@frame" attribute="@class" value="$in ? 'down' : ''/&gt;
  &lt;/watch&gt;
  &lt;watch&gt; <span class="watch">8</span>
    &lt;get property="enabled"/&gt;
    &lt;set select="@frame" attribute="@class" value="$in ? '' : 'disabled'/&gt;
  &lt;/watch&gt;
&lt;/component&gt;</pre>
      </div>
    </div>

    <p>The figure below shows the rendered graph for <code>Panel</code>.
    Vertices are represented by ovals (properties), heptagons (events),
    squares (watches), and a triangle for the vortex. Edges are represented
    by arrows between the vertices; <code>InheritEdges</code> are pink while
    yellow edges are edges that were copied from the prototype vertex. In this
    case, there is an edge from the <code>enabled</code> property vertex of
    <code>Button</code> to <span class="watch">8</span>, which is copied to the
    <code>enabled</code> property vertex of <code>Minus</code>.</p>

    <figure>
      <img src="fig/graph-panel.svg">
      <figcaption>The watch graph for the <code>Panel</code>
      component.</figcaption>
    </figure>

    <h2>Rendering to HTML</h2>
    <p>A component is rendered to HTML by creating its <em>view stack</em> and
    rendering that stack into a HTML element, such as a <code>div</code>, the
    <code>body</code> of a document, or an <code>iframe</code>.</p>

    <pre class="code">render-component(Component C, DOM element T) = render-view-stack(view-stack(C), T)</pre>

    <h3 id="view-stack">The View Stack</h3>
    <p>The <em>view stack</em> of a component is the stack of the views of the
    component, its prototype, its prototype’s view, and so on. The views along
    the prototype chain are actually new views created from the original views
    so that a component may modify its version of a view in the view stack
    without affecting other components created from the same prototype. For a
    <code>Component</code> <em>C</em>, the bottom-most view in the stack
    (<em>i.e.</em>, the first element in the list of views returned by
    <code>view-stack(C)</code>, with index 0) is a view of the furthest
    prototype, while the last element in the list is the view of <em>C</em>.
    Because components always have a view but may not have a prototype, the view
    stack has a length of 1 (for components with no prototype) or more (for
    components with a prototype.)</p>
    <pre class="code">View+ view-stack(Component C) = bottom-view-stack(C) : C.view
View+ view-stack’(Component C) = bottom-view-stack(C) : clone-element(C.view)
View+ bottom-view-stack(Component C) = if defined? C.prototype
                                         then view-stack’(C.prototype)
                                         else []</pre>

    <p>The <code>clone-element(E, P)</code> function creates a copy of a
    <code>Node</code> <em>E</em> and its children and add it as a child of its
    parent <em>P</em>. In the case of a <code>View</code> element, a clone of
    the <code>Component</code> is also created for the <code>component</code> of
    the view, while maintaining the parent/children relationships of the
    component tree (so that in effect view tree and component tree are cloned in
    parallel.)</p>
    <pre class="code">Element clone-element(Element E, Element? P) =
  let E’ = create(E) in
    do
      E’.parent = P
      E’.children = map(E.children, λC clone-element(C, E’))
      if E’ is-a View &amp; defined? P
        clone-component(E’)
      E’</pre>
    <p>When a view <em>V</em> that is not the view of a top-level component is
    cloned, a clone of the component of <em>V</em> is made as well, so that this
    component can keep its own state independently of its prototype. The clone
    is <em>shallow</em>, because the children of the component will be cloned
    when the <code>View</code> children of <em>V</em> will be cloned. The
    hierarchy of the component tree is not preserved, but it is not required for
    the copies. Lastly, the component of the top-level view is never cloned
    because its state is maintained by the component that this is the prototype
    of.</p>
    <pre class="code">clone-component(View V) =
  let C’ = create(V.component)
    in
      V.component = C’
      C’.view = V</pre>

    <p>To illustrate the process, consider the following component tree. Black
    arrows point from parent to child, while pink arrows point from component
    to prototype. In this example, a component <em>A</em> has two children
    <em>B<sub>1</sub></em> and <em>B<sub>2</sub></em> which both inherit from
    <em>B</em>, which itself has two children, <em>C</em> and <em>D</em>.</p>

    <figure>
      <img src="fig/view-stack-1.svg">
      <figcaption>Static component tree (before rendering.)</figcaption>
    </figure>

    <p>The complete tree of views after the view stacks have been created is
    shown below. The pink lines indicate views in the same stack. It can be
    seen that the view of <em>B</em> was cloned twice into <em>B’</em> and
    <em>B”</em>, for the view stack of <em>B<sub>1</sub></em> and
    <em>B<sub>2</sub></em>; and likewise for its children <em>C</em> and
    <em>D</em>.</p>

    <figure>
      <img src="fig/view-stack-2.svg">
      <figcaption>The rendered view tree of <em>A</em>.</figcaption>
    </figure>

    <p>Finally, the component tree after the view stack was created is shown
    below. Note that while <em>B</em> was not cloned, because it is a top-level
    component, <em>C</em> and <em>D</em> have both been cloned twice. The dashed
    arrows indicate that the parent/child relationships are not maintained for
    copies of component (since B is not copied, the parent of C’ is still B,
    but B does not have C’ as its child) but this relationship is only pertinent
    in the static tree.</p>
    <figure>
      <img src="fig/view-stack-3.svg">
      <figcaption>Dynamic component tree (after the view stack was
      created.)</figcaption>
    </figure>

    <h3>Rendering Elements in a View Stack</h3>
    <p>Rendering a view stack <em>S</em> in a target DOM element <em>T</em> is
    simply rendering the bottom-most view in the stack, <em>i.e.</em> the
    element at index 0 in the list of <code>View</code>s.</p>
    <pre class="code">render-view-stack(View+ S, DOM element T) = render-element(S, 0, S<sub>0</sub>, T)</pre>

    <p>Rendering an element <em>E</em> from the view at index <em>I</em> in the
    view stack <em>S</em> in a target DOM element <em>T</em> depends on the type
    of the element to render.</p>
    <pre>render-element(View+ S, integer I, Element E, DOM element T) =
  case E of
    View = render-view(S, I, E, T)
    Content = render-content(S, I, E, T)
    DOMElement = render-dom-element(S, I, E, T)
    Attribute = render-attribute(E, T)
    Text = render-text(E, T)</pre>

    <p>Rendering a <code>View</code> element depends on whether the view is a
    member of the view stack, <em>i.e.</em>, the view of the component or of one
    of its prototypes; or the view of a child component. In the former case, the
    child elements of the view are rendered in the target element. In the latter
    case, <code>render-component</code> is callled on the child component.</p> 
    <pre>render-view(View+ S, integer I, View V, DOM element T) =
  if V == S<sub>I</sub>
    then render-children(S, I, V, T)
    else render-component(V.component, T)
render-children(View+ S, integer I, Element E, DOM element T) =
  for C in E.children
    render-element(S, I, C, T)</pre>

    <p>Rendering a <code>Content</code> element depends on the view stack. If
    there is a non-empty <code>View</code> (with at least on child) above the
    current <code>View</code> in the stack, then render that view. If no such
    view exists, then render the children of the element as the default
    content using <code>render-children</code> as seen above.</p>
    <pre>render-content(View+ S, integer I, Content C, DOM element T) =
  let J = next-view-index(S, I + 1) in
    if J &lt; length S
      then render-view(S, J, S<sub>J</sub>, T)
      else render-children(S, I, C, T)
integer next-view-index(View+ S, integer I) =
  if I &lt; length S
    then if length S<sub>I</sub>.children == 0
      then next-view-index(S, I + 1)
      else I
    else I</pre>

    <p>Rendering a <code>DOMElement</code> <em>D</em> is adding a new DOM
    element <em>N</em> to <em>T</em>, then rendering the children of <em>D</em>
    in <em>N</em>.</p>
    <pre>render-dom-element(View+ S, integer I, DOMElement D, DOM element T) =
  let N = new DOM element node in
    do
      N.namespace-uri = D.ns
      N.local-name = D.name
      N.attributes = D.attrs
      render-children(S, I, D, N)
      append-child(T, N)</pre>

    <p>Rendering an <code>Attribute</code> <em>A</em> is setting an attribute on
    the target element with the value resulting from the concatenation of the
    text value of the child elements of <em>A</em>.</p>
    <pre>render-attribute(Attribute A, DOM element T) =
  set-attribute-ns(T, E.ns, E.name, fold(E.children, "",
                                         λZ,C Z :: (case C of
                                                      Text = C.text,
                                                       otherwise = "")))</pre>

    <p>Rendering a <code>Text</code> element <em>E</em> is adding a new text
    node to <em>T</em> with the text content of <em>E</em>.</p>
    <pre>render-text(Text E, DOM element T) =
  let N = new DOM text node in
    do
      N.text-content = E.text
      append-child(T, N)</pre>


    <h2>Watch Graph Traversal</h2>
    <p>The watch graph is traversed when one of its <em>input vertices</em>
    is activated with a value. Edges of the graph are then traversed in the
    sorted order. Edges have different effects on the application, such as
    setting property values, generating events, modifying rendered elements,
    &amp;c. The order of the edges defines the order in which these changes
    occur. After all edges have been visited, vertex values are cleared until
    the next traversal.</p>

    <h3>Input Vertices and Vertex Values</h3>
    <p>Both a <code>PropertyVertex</code> and an <code>EventVertex</code> can
    act as input vertices and be <em>activated</em>. A <code>PropertyEdge</code>
    is activated when the corresponding property is set to a new value
    externally. An <code>EventVertex</code> is actiaved when the corresponding
    event notification is received.</p>
    <p>A vertex represents a <code>Watch</code> or <code>Adapter</code> for a
    </p>

    <p><span class="TODO">Replace scope with context</span>.<p>

    <div class="def" id="VertexValue">
      <p>A <code>VertexValue</code> is a value associated with a
      <code>Vertex</code> and a <code>Context</code> during graph traversal. The
      value itself can be any <code>data</code>.</p>
      <div>
        <pre>VertexValue = (Scope, data)</pre>
        <ul>
          <li>A <code>Vertex</code> in a <code>Graph</code> can have zero or
          more associated values, which can be retried with the function
          <code>VertexValue* get-vertex-values(Graph G, Vertex V)</code>.</li>
          <li>A <code>VertexValue</code> can be set for a <code>Vertex</code> in
          a <code>Graph</code> with the function <code>set-vertex-value(Graph G,
            Vertex V, VertexValue W)</code>. Any previous value with the same
          <code>Scope</code> is replaced with the new value, otherwise a new
          value is added to the list of values.</li>
          <li>All vertex values can be cleared from a <code>Graph</code> with
          the function <code>clear-vertex-values(Graph G)</code>.</li>
        </ul>
      </div>
    </div>


    <h3>Edge Traversal</h3>
    <p>Every edge of the graph is visited in turn.</p>
    <pre class="code">traverse-graph(Graph G) =
  do
    for E in G.edges
      traverse-edge(E)
    clear-vertex-values(G)</pre>

    <p>Traversing and edge means filtering input values (from the source
    vertex), computing output values, and <em>applying</em> them.</p>
    <pre class="code">traverse-edge(Edge E) =
  for (S, V) in get-vertex-values(G, E.source)
    let S’ = enter-scope(E, S) in
      if defined? S’ &amp; match-edge(E, S’, V)
        let V’ = apply-edge(E, S’, V) in
          for S” in exit-scopes(E, S’)
            set-vertex-value(G, E.dest, (S”, V’))</pre>

    <p>Enter scope: InheritEdge and edges to a watch vertex.</p>
    <pre class="code">Scope? enter-scope(Edge E, Scope S) =
  case E of
    InheritEdge = enter-scope-inherit(E, S)
    AdapterEdge = case E.dest of
                    WatchVertex = enter-scope-get(E, S)
                    otherwise = S
    otherwise = S</pre>

    <p><code>enter-scope-inherit</code> handles the case of an
    <code>InheritEdge</code>.</p>
    <pre class="code">Scope? enter-scope-inherit(InheritEdge E, Scope S) =
  find(stack-of(S), λN </pre>

    <p><code>enter-scope-get</code> handles the enter scope for an
    <code>AdapterEdge</code> </p>

Scope? enter-scope-get(AdapterEdge E, Scope S) =</pre>

    <p>The <code>match-edge</code> function is a predicate used to filter input
    values for an edge using the <code>match</code> function of the adapter of
    the edge. Remember that the default value for <code>match</code> is a
    function that returns true.</p>
    <pre class="code">boolean match-edge(Edge E, Scope S, data V) = E.adapter.match(V, S)</pre>

    <p>The <code>apply-edge</code> function has two roles:</p>
    <ol>
      <li>compute the input value of the edge from its input value;</li>
      <li>apply the value according to the type of edge.</li>
    </ol>
    <pre class="code">data apply-edge(Edge E, Scope S, data V) =
  case E of
    AdapterEdge = apply-edge’(E, S, V)
    otherwise = V
data apply-edge’(Edge E, Scope S, data V) =
  let V’ = E.adapter.value(V, S) in
    do
      case E.adapter of
        SetProperty = apply-property(E.adapter, S, V)
        SetAttribute = apply-attribute(E.adapter, S, V)
        SetEvent = apply-event(E.adapter, S, V)
        otherwise = nothing
      V’
    </pre>

    <p>Exit scopes</p>
    <pre class="code">Scope* exit-scope(Edge E, Scope S) =
  if E is-a AdapterEdge &amp; E.source is-a WatchVertex
    then exit-scope’(E, S)
    else S
Scope exit-scope’(AdapterEdge E, Scope S) =</pre>

    <h3>Example</h3>
    <p>Using the example graph shown above, the process of graph traversal is
    illustrated in the figure below. The relevant state of the application at
    the instant before graph traversal begins is as follows:</p>
    <ul>
      <li>The <code>n</code> property of <code>Panel</code> has value 2.</li>
      <li>The <code>down</code> property of <code>Plus</code> has value true
      (the button has been pressed.)</li>
      <li>The <code>frame</code> of <code>Plus</code> has just received a
      <code>mouseup</code> event.</li>
    </ul>

    <figure>
      <img src="fig/graph-traverse.svg">
      <figcaption>Graph traversal after a <code>mouseup</code> event in the
      <code>Plus</code> child of the <code>Panel</code> component. </figcaption>
    </figure>

    <p>The <code>mouseup</code> event vertex was just activated for the
    <code>Plus</code> button with an event value. The graph traversal then
    starts, following edges in the order below (dashed edges are not followed
    as they have no input value and are omitted for brevity), with the following
    effects:
    <ol>
      <li>A DOM event is received from the <code>frame</code> DOM element of the
      clone of the view of <code>Button</code> for the <code>Plus</code>
      component (abbreviated <code>Button/Plus</code>.)</li>
      <li>The <code>down</code> property of <code>Plus</code> is set to
      false.</li>
      <li>The <code>down</code> property of <code>Plus</code> is passed to
      <span class="watch">7</span>.</li>
      <li>The <code>class</code> of the view <code>Button/Plus</code> is set to
      "".</li>
      <li>A <code>pushed</code> event is generated for the <code>Plus</code>
      component.</li>
      <li>This <code>InheritEdge</code> cannot be followed because
      <code>Plus</code> is not in the view stack of <code>Minus</code>.</li>
      <li>This <code>InheritEdge</code> is followed for <code>Plus</code> with
      the generated event as the value.</li>
      <li>The event value from <code>Plus</code> is passed to
      <span class="watch">1</span>.</li>
      <li>The property <code>n</code> of <code>Panel</code> is set to 3.</li>
      <li>The property <code>n</code> of <code>Panel</code> is passed to
      <span class="watch">3</span>.</li>
      <li>The property <code>enabled</code> of <code>Minus</code> is set to
      true.</li>
      <li>The property <code>enabled</code> of <code>Minus</code> is passed to
      <span class="watch">8</span>.</li>
      <li>The DOM text node <code>text-n</code> of <code>Panel</code> is updated
      to show the text "3".</li>
      <li>The <code>class</code> attribute of the <code>frame</code> of
      <code>Button/Minus</code> is set to "".</li>
    </ol>

    <h3>Delayed edge traversal</h3>
    <p><code>Adapter</code>s have a <code>delay</code> property. If that delay
    is a positive number, then the traversal of the edge corresponding to that
    adapter is <em>delayed</em>. No value is set on the target vertex, but a
    new graph traversal is scheduled to take place after the delay has elapsed.
    If the delay was 0, then the new traversal happens as soon as possible after
    the current traversal has ended; otherwise, a timer is set to start the
    traversal after the amount of time given by <code>delay</code>. Note that
    several delayed traversals may be scheduled from a given graph
    traversal.</p>
    <p>In the example traversal above, the <code>SetEvent</code> of <span
    class="watch">6</span> should have a delay of 0 so that the event is
    dispatched asynchronously. This means that edges 1 through 4 are traversed
    as above, but edge 5 is delayed. After the traversal has ended, a new
    traversal starts from edge 5, with the false value on the <code>Plus</code>
    button, and edges 6 through 14 are traversed as usual.</p>
    <p>Delayed edge traversal allows the graph to contain cycles, as long as at
    least one edge in the cycle has a delay. When sorting the edges of the
    graph, all edges with a delay are pushed back to the end of the list of
    edges, then the remaining edges can be sorted since possible cycles have
    been broken. Note that while this ensures that the edges can be sorted,
    in order to avoid an infinite number of traversal, there must be conditional
    edges (<em>i.e.</em>, edges for which the <code>match</code> predicate is
    not always true) in every cycle as well.</p>


    <h2>Property Initialization</h2>
    <p><span class="TODO">Property vertices are initialized with the initial
    value of the <code>Adapter</code>.</span></p>

    <pre class="code">init-properties(Component C, Graph G) = ...</pre>

    <h3>Example</h3>

    <figure>
      <img src="fig/graph-init.svg">
      <figcaption>Initialization of the graph of the <code>Panel</code>
      component.</figcaption>
    </figure>


    <h2>Component Mutations</h2>
    <p><span class="TODO">Re-render but keep previous values instead of initial
      values.</p>

  </body>
</html>

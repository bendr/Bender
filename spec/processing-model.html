<!DOCTYPE html>
<html lang="en">
  <head>
    <title>The Bender Processing Model (v0.9, February 2014)</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="doc.css">
  </head>
  <body>
    <h1>The Bender Processing Model</h1>
    <p>Version 0.9, February 2014</p>
    <p>See also <a href="data-model.html">the Bender Data Model</a> for
    reference.</p>


    <h2>Running a Bender Application</h2>
    <p>A Bender application is defined by a top-level component and is run in by
    rendering the view and watches of the component, its children and their
    prototype in a host application (<em>e.g.</em>, a Web browser.)</p>
    <pre class="code">run-application(Component C, DOM element T) =
  let G = new Graph in
    do
      render-subgraph(C, G)
      render-component(C, T)
      init-properties(C, G)</pre>
    

    <h2>Rendering the Watch Graph</h2>
    <p>The <em>watch graph</em> is a graph of that is built to manage the flow
    of events and property changes in a Bender application.</p>

    <div class="def" id="Graph">
      <p>The <code>Graph</code> is defined as a set of directed <em>edges</em>
      between <em>vertices</em>. Edges are kept sorted in <em>topological
      order</em> so that data flow is consistent and predictible. This also
      means that the graph should be acyclic; however, through the use of
      <em>delayed</em> edges (see below), cycles may be introduced.</p>
      <div>
        <pre>Graph &lt; Object:
  Vertex+  vertices
  Vertex   vortex
  Edges*   edges</pre>
        <ul>
          <li><code>vertices</code> is the unordered list of vertices. It always
          contains at least one <code>Vertex</code> (the
          <code>vortex</code>.)</li>
          <li><code>vortex</code> is a <em>sink state</em> of the graph. It
          has no outgoing edge and is a member of <code>vertices</code>.</li>
          <li><code>edges</code> is the ordered list of edges between vertices
          in the graph.</li>
        </ul>
      </div>
    </div>


    <h3>Graph Vertices</h3>

    <div class="def" id="Vertex">
      <p>A <code>Vertex</code> in the <code>Graph</code>.</p>
      <div>
        <pre>Vertex &lt; Object:
  Edge*  incoming
  Edge*  outgoing</pre>
        <ul>
          <li><code>incoming</code> is the unordered list of incoming
          <code>Edge</code>s, <em>i.e.</em> edges that have this vertex as
          destination.</li>
          <li><code>outgoing</code> is the unordered list of outgoing
          <code>Edge</code>s, <em>i.e.</em> edges that have this vertex as
          source.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="WatchVertex">
      <p>A <code>WatchVertex</code> is a vertex representing a
      <code>Watch</code> of a <code>Component</code>.</p>
      <div>
        <pre>WatchVertex &lt; Vertex
  Watch  watch</pre>
        <ul>
          <li><code>watch</code> is the <code>Watch</code> for this vertex.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="AdapterVertex">
      <p>An <code>AdapterVertex</code> is a vertex representing a
      <code>Get</code> or <code>Set</code> in a <code>Watch</code>.</p>
      <div>
        <pre>AdapterVertex &lt; Vertex
  Adapter  adapter</pre>
        <ul>
          <li><code>adapter</code> is the <code>Get</code> or <code>Set</code>
          for this vertex.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="PropertyVertex">
      <p>A <code>PropertyVertex</code> is a vertex representing a
      <code>GetProperty</code> or <code>SetProperty</code> in a
      <code>Watch</code>.</p>
      <div>
        <pre>PropertyVertex &lt; AdapterVertex</pre>
  Property  property</pre>
        <ul>
          <li><code>property</code> is the <code>Property</code> of the
          <code>adapter</code> of this vertex.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="EventVertex">
      <p>An <code>EventVertex</code> is a vertex representing a
      <code>GetEvent</code> or <code>SetEvent</code> in a
      <code>Watch</code>.</p>
      <div>
        <pre>PropertyVertex &lt; AdapterVertex</pre>
  string  type</pre>
        <ul>
          <li><code>property</code> is the <code>Property</code> of the
          <code>adapter</code> of this vertex.</li>
        </ul>
      </div>
    </div>

    <h3>Graph Edges</h3>

    <div class="def" id="Edge">
      <p>An <code>Edge</code> is a directed transition from a <em>source</em> to
      a <em>destination</em> vertex.</p>
      <div>
        <pre>Edge &lt; Object:
  Vertex  source
  Vertex  dest</pre>
        <ul>
          <li><code>source</code> is the source vertex of the edge.</li>
          <li><code>dest</code> is the destination vertex of the edge.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="AdapterEdge">
      <p>An <code>AdapterEdge</code> is an edge rendered from a <code>Get</code>
      or <code>Set</code>.</p>
      <div>
        <pre>AdapterEdge &lt; Object:
  Adapter  adapter</pre>
        <ul>
          <li><code>adapter</code> is the <code>Get</code> or <code>Set</code>
          for this edge.</li>
        </ul>
      </div>
    </div>

    <h3>Rendering the Watch Graph of a Component</h3>

    <p>The sub-graph of a <code>Component</code> in a <code>Graph</code>
    <em>G</em> is rendered by rendering the sub-graph of the prototype of the
    component, if any, in <em>G</em>; then rendering vertices and edges for
    every <code>Watch</code>; and finally rendering the sub-graph of the child
    components. The component is marked as being rendered so that its sub-graph
    is rendered only once. This is necessary because a prototype component may
    be shared by several components.</p>
    <pre class="code">render-subgraph(Component C, Graph G) =
  do mark C
    if defined? C.prototype and not marked? C.prototype
      then render-subgraph(C.prototype, G)
    for W in C.Watches
      render-watch(W, G)
    for C’ in C.children
      render-subgraph(C’, G)</pre>

    <p>The sub-graph for a <code>Watch</code> <em>W</em> is rendered by
    creating a new <code>WatchVertex</code> <em>V</em> in <em>G</em>, then an
    <code>AdapterEdge</code> to <em>V</em> for each <code>Get</code> of
    <em>W</em>, and an <code>AdapterEdge</code> from <em>V</em> for every
    <code>Set</code> of <em>W</em>.</p>
    <pre class="code">render-watch(Watch W, Graph G) =
  let V = new WatchVertex(W) in
    do
      G.vertices = G.vertices : V
      for H in W.gets
        let V’ = find-adapter-vertex(H, G) in
          G.edges = G.edges : new AdapterEdge(V’, V, H)
      for S in W.sets
        let V’ = find-adapter-vertex(S, G) in
          G.edges = G.edges : new AdapterEdge(V, V’, S)</pre>

    <p>The source or destination vertex of an <code>AdapterEdge</code> to or
    from a <code>WatchVertex</code> is a <code>PropertyVertex</code>,
    <code>EventVertex</code> or <code>DOMEventVertex</code>, depending on the
    adapter. A vertex may be the source and destination of several edges, so
    it is created the first time that it is needed and added to the graph.
    Subsequent calls to <code>find-adapter-vertex(A, G)</code> will return the
    already created vertex.</p>
    <pre class="code">AdapterVertex find-adapter-vertex(Adapter A, Graph G) =
  let V = find(G.vertices, λV V is-a AdapterVertex &amp; V.adapter == A) in
    if defined? V
      then V
      else
        let V’ = new AdapterVertex(A) in
          do
            G.vertices = G.vertices : V’
            add-inherit-edge(V’, G)
            V’</pre>

    <p>If a component <em>C</em> has <em>e.g.</em> a <code>GetProperty</code>
    for a <code>Property</code> <em>P</em>, then a <code>PropertyVertex</code>
    <em>V</em> will exist for <em>P</em> in <em>G</em>. Now, if there exists a
    component <em>C’</em> that is the nearest ancestor of <em>C</em> along the
    prototype chain such that there exists a <code>PropertyVertex</code>
    <em>V’</em> for that same property <em>P</em> in <em>G</em>, a new
    <code>InheritEdge</code> is created between <em>V’</em> and <em>V</em>.
    Then, for every outgoing edge <em>E</em> of <em>V’</em>, a copy <em>E’</em>
    of <em>E</em> is added to the outgoing edges of <em>V</em>. By using
    <code>InheritEdge</code>s and copying edges in this manner, we ensure that
    a component shares the behavior of its prototype. The role of
    <code>InheritEdge</code>s is described in more detail below.</p>
    <pre class="code">add-inherit-edge(AdapterVertex V, Graph G) =
  let V’ = find-prototype-vertex(V, G) in
    if defined? V’ then
      do
        G.edges = G.edges : new InheritEdge(V’, V)
        for E in V’.outgoing
          let E’ = create(E) in
            do
              E’.source = V
              G.edges = G.edges : E’</pre>

    <p><span class="TODO">Find the prototype vertex for the
      <code>InheritEdge</code>; go up the prototype chain and look for a vertex
      for the same accessor defined on the component.</p>
    <pre class="code">AdapterVertex? find-prototype-vertex(Graph G, AdapterVertex V) =
  find-prototype-vertex’(G, V, V.adapter.watch.component.prototype)

AdapterVertex? find-prototype-vertex’(Graph G, AdapterVertex V, Component? C) =
  ...</pre>
      

    <h2>Rendering to HTML</h2>
    <p>A component is rendered to HTML by creating its <em>view stack</em> and
    rendering that stack into a HTML element, such as a <code>div</code>, the
    <code>body</code> of a document, or an <code>iframe</code>.</p>

    <pre class="code">render-component(Component C, DOM element T) = render-view-stack(view-stack(C), T)</pre>

    <h3 id="view-stack">The View Stack</h3>
    <p>The <em>view stack</em> of a component is the stack of the views of the
    component, its prototype, its prototype’s view, and so on. The views along
    the prototype chain are actually new views created from the original views
    so that a component may modify its version of a view in the view stack
    without affecting other components created from the same prototype. For a
    <code>Component</code> <em>C</em>, the bottom-most view in the stack
    (<em>i.e.</em>, the first element in the list of views returned by
    <code>view-stack(C)</code>, with index 0) is a view of the furthest
    prototype, while the last element in the list is the view of <em>C</em>.
    Because components always have a view but may not have a prototype, the view
    stack has a length of 1 (for components with no prototype) or more (for
    components with a prototype.)</p>
    <pre class="code">View+ view-stack(Component C) = bottom-view-stack(C) : C.view
View+ view-stack’(Component C) = bottom-view-stack(C) : clone-element(C.view)
View+ bottom-view-stack(Component C) = if defined? C.prototype
                                         then view-stack’(C.prototype)
                                         else []</pre>

    <p>The <code>clone-element(E, P)</code> function creates a copy of a
    <code>Node</code> <em>E</em> and its children and add it as a child of its
    parent <em>P</em>. In the case of a <code>View</code> element, a clone of
    the <code>Component</code> is also created for the <code>component</code> of
    the view, while maintaining the parent/children relationships of the
    component tree (so that in effect view tree and component tree are cloned in
    parallel.) The component tree is cloned so that each component may maintain
    its own state independently of its prototype.</p>
    <pre class="code">Element clone-element(Element E, Element? P) =
  let E’ = create(E) in
    do
      E’.parent = P
      E’.children = map(E.children, λC clone-element(C, E’))
      if E’ is-a View
        clone-component(E’)
      E’
clone-component(View V) =
  let C’ = create(V.component)
    in
      V.component = C’
      C’.view = V
      C’.children = []
      if defined? V.parent
        then do
          C’.parent = V.parent.component
          C’.parent.children = C’.parent.children : C’</pre>

    <h3>Rendering Elements in a View Stack</h3>
    <p>Rendering a view stack <em>S</em> in a target DOM element <em>T</em> is
    simply rendering the bottom-most view in the stack, <em>i.e.</em> the
    element at index 0 in the list of <code>View</code>s.</p>
    <pre class="code">render-view-stack(View+ S, DOM element T) = render-element(S, 0, S<sub>0</sub>, T)</pre>

    <p>Rendering an element <em>E</em> from the view at index <em>I</em> in the
    view stack <em>S</em> in a target DOM element <em>T</em> depends on the type
    of the element to render.</p>
    <pre>render-element(View+ S, integer I, Element E, DOM element T) =
  case E of
    View = render-view(S, I, E, T)
    Content = render-content(S, I, E, T)
    DOMElement = render-dom-element(S, I, E, T)
    Attribute = render-attribute(E, T)
    Text = render-text(E, T)</pre>

    <p>Rendering a <code>View</code> element depends on whether the view is a
    member of the view stack, <em>i.e.</em>, the view of the component or of one
    of its prototypes; or the view of a child component. In the former case, the
    child elements of the view are rendered in the target element. In the latter
    case, <code>render-component</code> is callled on the child component.</p> 
    <pre>render-view(View+ S, integer I, View V, DOM element T) =
  if V == S<sub>I</sub>
    then render-children(S, I, V, T)
    else render-component(V.component, T)
render-children(View+ S, integer I, Element E, DOM element T) =
  for C in E.children
    render-element(S, I, C, T)</pre>

    <p>Rendering a <code>Content</code> element depends on the view stack. If
    there is a non-empty <code>View</code> (with at least on child) above the
    current <code>View</code> in the stack, then render that view. If no such
    view exists, then render the children of the element as the default
    content using <code>render-children</code> as seen above.</p>
    <pre>render-content(View+ S, integer I, Content C, DOM element T) =
  let J = next-view-index(S, I + 1) in
    if J &lt; length S
      then render-view(S, J, S<sub>J</sub>, T)
      else render-children(S, I, C, T)
integer next-view-index(View+ S, integer I) =
  if I &lt; length S
    then if length S<sub>I</sub>.children == 0
      then next-view-index(S, I + 1)
      else I
    else I</pre>

    <p>Rendering a <code>DOMElement</code> <em>D</em> is adding a new DOM
    element <em>N</em> to <em>T</em>, then rendering the children of <em>D</em>
    in <em>N</em>.</p>
    <pre>render-dom-element(View+ S, integer I, DOMElement D, DOM element T) =
  let N = new DOM element node in
    do
      N.namespace-uri = D.ns
      N.local-name = D.name
      N.attributes = D.attrs
      render-children(S, I, D, N)
      append-child(T, N)</pre>

    <p>Rendering an <code>Attribute</code> <em>A</em> is setting an attribute on
    the target element with the value resulting from the concatenation of the
    text value of the child elements of <em>A</em>.</p>
    <pre>render-attribute(Attribute A, DOM element T) =
  set-attribute-ns(T, E.ns, E.name, fold(E.children, "",
                                         λZ,C Z :: (case C of
                                                      Text = C.text,
                                                       otherwise = "")))</pre>

    <p>Rendering a <code>Text</code> element <em>E</em> is adding a new text
    node to <em>T</em> with the text content of <em>E</em>.</p>
    <pre>render-text(Text E, DOM element T) =
  let N = new DOM text node in
    do
      N.text-content = E.text
      append-child(T, N)</pre>


    <h2>Scoping</h2>
    <p><span class="TODO">TODO</span></p>

    <p>Bender nodes (components and view elements) can all have an ID. IDs are
    visible, and must be unique, within a <em>scope</em>. Bender defines a
    <em>component scope</em>, introduced by a top-level component, and including
    all descendant components, <em>i.e.</em>, spanning the whole component
    tree.</p>


    <h2>Watch Graph Traversal</h2>
    <p><span class="TODO">TODO</span></p>


    <h2>Property Initialization</h2>
    <p><span class="TODO">TODO</span></p>

    <pre class="code">init-properties(Component C, Graph G) = ...</pre>

    <h2>Component Mutations</h2>
    <p><span class="TODO">Re-render but keep previous values instead of initial
      values.</p>

  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>The Bender Processing Model (v0.9, February 2014)</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="doc.css">
  </head>
  <body>
    <h1>The Bender Processing Model</h1>
    <p>Version 0.9, February 2014</p>
    <p>See also <a href="data-model.html">the Bender Data Model</a> and <a
      href="runtime.html">the Bender Runtime</a> for reference.</p>


    <h2>Overview</h2>
    <p>A Bender application is defined by a component, its children, and their
    prototype. The graph of all components that are part of the definition of an
    application is called the <em>component graph</em> of the application.
    At runtime, the component graph is augmented with copies of views and
    components; the result is the <em>runtime graph</em>.</p>
    <p>Copies of nodes are necessary in when several components have a common
    prototype, as child components of a shared prototype component need copying
    in order to maintain their own state independently of each other. The views
    of the runtime graph are then rendered by the user agent, and a <em>watch
      graph</em> is also constructed.</p>
    <p>The watch graph is a compilation of all the watches in the component
    graph. The main idea behind the watch graph is to create edges between
    vertices, where a vertex represents the value of a property or the
    occurrence of an event, and edges the changes that happen in between. When
    a value changes or an event occurs, that value is propagated through the
    edges and vertices of the graph, having effects on the running
    application.</p>


    <h2>Running a Bender Application in a User Agent</h2>
    <p>Running a Bender application in a user agent, such as a Web browser, is
    rendering the <code>Component</code> in a target DOM element.</p>
    <pre class="code">render-component(Component C, DOM element T) =
  let G = new WatchGraph in
    do
      render-subgraph(C, G)
      render-component-view(C, T)
      sort-watch-graph(G)
      init-properties(C, G)</pre>


    <h2>Constructing the Watch Graph</h2>

    <div class="def" id="WatchGraph">
      <p>The <code>WatchGraph</code> is defined as a list of directed
      <em>edges</em> between <em>vertices</em>. Edges are eventually sorted in
      <em>topological order</em> so that data flow is consistent and
      predictable. This also means that the graph should be acyclic; however,
      through the use of <em>delayed</em> edges (see below), cycles may be
      introduced under certain conditions.</p>
      <div>
        <pre>WatchGraph &lt; Object
  Vertex+  vertices
  Vertex   vortex
  Edges*   edges</pre>
        <ul>
          <li><code>vertices</code> is the set of list of vertices that are
          the source or destination of the <code>Edge</code>s. It always
          contains at least one <code>Vertex</code> (the
          <code>vortex</code>.)</li>
          <li><code>vortex</code> is a <em>sink state</em> in the watch graph.
          It has no outgoing edge and is a member of <code>vertices</code>.</li>
          <li><code>edges</code> is the list of edges between vertices in the
          graph.</li>
        </ul>
      </div>
    </div>


    <h3>Vertices</h3>

    <div class="def" id="Vertex">
      <p>A vertex in the <code>WatchGraph</code>.</p>
      <div>
        <pre>Vertex &lt; Object
  Edge*  incoming
  Edge*  outgoing</pre>
        <ul>
          <li><code>incoming</code> is the set of incoming <code>Edge</code>s,
          <em>i.e.</em> edges that have this vertex as destination.</li>
          <li><code>outgoing</code> is the set of outgoing <code>Edge</code>s,
          <em>i.e.</em> edges that have this vertex as source.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="WatchVertex">
      <p>A <code>WatchVertex</code> is a vertex representing a
      <code>Watch</code> of a <code>Component</code>.</p>
      <div>
        <pre>WatchVertex &lt; Vertex
  Watch  watch</pre>
        <ul>
          <li><code>watch</code> is the <code>Watch</code> for this vertex.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="AdapterVertex">
      <p>An <code>AdapterVertex</code> is a vertex representing a
      <code>Get</code> or <code>Set</code> in a <code>Watch</code>.</p>
      <div>
        <pre>AdapterVertex &lt; Vertex
  Adapter  adapter</pre>
        <ul>
          <li><code>adapter</code> is the <code>Get</code> or <code>Set</code>
          for this vertex.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="PropertyVertex">
      <p>A <code>PropertyVertex</code> is a vertex representing a
      <code>GetProperty</code> or <code>SetProperty</code> in a
      <code>Watch</code>.</p>
      <div>
        <pre>PropertyVertex &lt; AdapterVertex</pre>
        <ul>
          <li><strong>Note</strong>: the <code>Adapter</code> of the vertex
          being either a <code>GetProperty</code> or <code>SetProperty</code>,
          the property associated with this vertex is accessible through
          <code>adapter.property</code>.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="EventVertex">
      <p>An <code>EventVertex</code> is a vertex representing a
      <code>GetEvent</code> or <code>SetEvent</code> in a
      <code>Watch</code>.</p>
      <div>
        <pre>EventVertex &lt; AdapterVertex</pre>
        <ul>
          <li><strong>Note</strong>: the <code>Adapter</code> of the vertex
          being either a <code>GetEvent</code> or <code>SetEvent</code>,
          the type of the event associated with this vertex is accessible
          through <code>adapter.type</code>.</li>
        </ul>
      </div>
    </div>

    <h3>Edges</h3>
    <div class="def" id="Edge">
      <p>An <code>Edge</code> is a directed transition from a <em>source</em> to
      a <em>destination</em> <code>Vertex</code>.</p>
      <div>
        <pre>Edge &lt; Object
  Vertex  source
  Vertex  dest
  number  priority = 0</pre>
        <ul>
          <li><code>source</code> is the source <code>Vertex</code> of the
          edge.</li>
          <li><code>dest</code> is the destination <code>Vertex</code> of the
          edge.</li>
          <li><code>priority</code> is a number that is used to sort the
          incoming edges of a <code>Vertex</code>. The lower the number,
          the higher the priority.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="InheritEdge">
      <p>An <code>InheritEdge</code> is an edge between two vertices
      representing the same property or event. The source of the
      <code>Edge</code> is the <em>prototype vertex</em> of the destination
      <code>Vertex</code>, and is a vertex for a <code>Component</code> that is
      in the prototype chain of the component of the destination
      <code>Vertex</code>. The purpose of <code>InheritEdge</code>s is to make
      components inherit the behavior of their prototype, while adding behavior
      of their own. Another benefit of these edges is to avoid situations that
      may lead to spurious cycles in the graph.</p>
      <div>
        <pre>InheritEdge &lt; Edge
  number  priority = 1</pre>
        <ul>
          <li><code>priority</code> is set to 1 so that these edges have a lower
          priority during sorting.</li>
        </ul>
      </div>
    </div>

    <div class="def" id="AdapterEdge">
      <p>An <code>AdapterEdge</code> is an <code>Edge</code> rendered from a
      <code>Get</code> or <code>Set</code>.</p>
      <div>
        <pre>AdapterEdge &lt; Object:
  Adapter  adapter</pre>
        <ul>
          <li><code>adapter</code> is the <code>Get</code> or <code>Set</code>
          for this edge.</li>
        </ul>
      </div>
    </div>

    <h3>Rendering the Watch Graph of a Component</h3>
    <p>The sub-graph of a <code>Component</code> <em>C</em> in a
    <code>WatchGraph</code> <em>G</em> is constructed by rendering the sub-graph
    of the prototype <em>C</em>, if any, in <em>G</em>; then rendering the
    sub-graph of the child components; and finally rendering vertices and edges
    for every <code>Watch</code> in <em>C</em>. The component is marked so that
    its sub-graph is rendered only once. This is necessary because a prototype
    component may be shared by several components, which will all require it
    to render its sub-graph.</p>
    <pre class="code">render-subgraph(Component C, WatchGraph G) =
  do
    mark C
    if defined C.prototype and not marked C.prototype
      then render-subgraph(C.prototype, G)
    for C’ in C.children
      render-subgraph(C’, G)
    for W in C.Watches
      render-watch(W, G)</pre>

    <p>The sub-graph for a <code>Watch</code> <em>W</em> is rendered by
    creating a new <code>WatchVertex</code> <em>V</em> in <em>G</em>, then an
    <code>AdapterEdge</code> to <em>V</em> for each <code>Get</code> of
    <em>W</em>, and an <code>AdapterEdge</code> from <em>V</em> for every
    <code>Set</code> of <em>W</em>.</p>
    <pre class="code">render-watch(Watch W, Graph G) =
  let V = new WatchVertex(W) in
    do
      G.vertices &lt;- G.vertices : V
      for H in W.gets
        let V’ = find-adapter-vertex(H, G) in
          G.edges &lt;- G.edges : new AdapterEdge(V’, V, H)
      for S in W.sets
        let V’ = find-adapter-vertex(S, G) in
          G.edges &lt;- G.edges : new AdapterEdge(V, V’, S)</pre>


    <p>The source or destination vertex of an <code>AdapterEdge</code> to or
    from a <code>WatchVertex</code> is a <code>PropertyVertex</code>,
    <code>EventVertex</code> or <code>DOMEventVertex</code>, depending on the
    adapter. A vertex may be the source and destination of several edges, so
    it is created the first time that it is needed and added to the graph.
    Subsequent calls to <code>find-adapter-vertex(A, G)</code> will return the
    already created vertex.</p>
    <pre class="code">AdapterVertex find-adapter-vertex(Adapter A, Graph G) =
  let V = find(G.vertices, λV V is-a AdapterVertex and V.adapter = A) in
    if defined V
      then V
      else
        let V’ = new AdapterVertex(A) in
          do
            G.vertices &lt;- G.vertices : V’
            add-inherit-edge(V’, G)
            V’</pre>

    <p>To illustrate the rendering of the watch graph, review the
    <code>Panel</code> component from the <a href="data-model.html#example">Data
    Model</a> description.</p>

    <p>The figure below shows the rendering of watch <span
    class="watch">6</span> of the <code>Button</code> example component (in this
    example, other watches are ignored.) A <code>WatchVertex</code> (square) is
    created, then an <code>AdapterEdge</code> to this vertex is added from a new
    <code>EventVertex</code> (heptagon) for the <code>GetEvent</code>, then two
    <code>AdapterEdge</code>s from the <code>WatchVertex</code> are created for
    the <code>SetProperty</code> to a <code>PropertyVertex</code> (ellipse) for
    the <code>down</code> <code>Property</code>, and another
    <code>AdapterEdge</code> for the <code>SetEvent</code> to an
    <code>EventVertex</code>.</p>

    <pre class="code">&lt;watch&gt; <span class="watch">6</span>
  &lt;get select="frame" event="mouseup"/&gt;
  &lt;set event="pushed" match="`down"/&gt;
  &lt;set property="down" value="false"/&gt;
&lt;/watch&gt;</pre>

    <figure>
      <img src="fig/graph-watch-6.svg">
      <figcaption>The watch sub-graph for watch <span class="watch">6</span> of
      the <code>Button</code>.</figcaption>
    </figure>

    <p>The figure below shows the addition of the sub-graph for watch <span
    class="watch">7</span>. A new <code>WatchVertex</code> is added, then a new
    <code>AdapterEdge</code> for the <code>GetProperty</code>, reusing the
    <code>PropertyVertex</code> of <code>down</code> as the source vertex.
    Finally, the <code>SetAttribute</code> is rendered as an
    <code>AdapterEdge</code> to the vortex (triangle.)</p>

    <pre class="code">&lt;watch&gt; <span class="watch">7</span>
  &lt;get property="down"/&gt;
  &lt;set select="frame" attribute="class" value="$in ? 'down' : ''/&gt;
&lt;/watch&gt;
    </pre>

    <figure>
      <img src="fig/graph-watch-67.svg">
      <figcaption>The watch sub-graph for watches <span class="watch">6</span>
      and <span class="watch">7</span> of the <code>Button</code>.</figcaption>
    </figure>

    <p>If there exists a prototype vertex <em>V’</em> for a vertex <em>V</em>
    (see below), then a new <code>InheritEdge</code> is added between
    <em>V’</em> and <em>V</em>. The outgoing edges of <em>V’</em> are also
    copied to <em>V</em> and given a higher priority so that they come later in
    a sort.</p>
    <pre class="code">add-inherit-edge(AdapterVertex V, Graph G) =
  let V’ = find-prototype-vertex(V, G) in
    if defined V’ then
      do
        G.edges &lt;- G.edges : new InheritEdge(V’, V)
        for E in V’.outgoing
          let E’ = create(E) in
            do
              E’.source &lt;- V
              E’.priority &lt;- -1
              G.edges &lt;- G.edges : E’</pre>

    <p><span class="TODO"><code>Vertex? find-prototype-vertex(Graph G,
    Vertex V)</code> finds the prototype vertex <em>V’</em> in <em>G</em> such
    that <em>V</em> and <em>V’</em> share the same property or event, and the
    component of <em>V’</em> is the closes component in the prototype chain of
    <em>V</em> that has such a vertex, if it exists.</p>

    <p>Continuing the previous example, adding watch <span
      class="watch">1</span> to the graph introduces a new vertex for the
    <code>pushed</code> event of <code>Plus</code>. Because <code>Plus</code>
    inherits from <code>Button</code>, a new <code>InheritEdge</code> is
    introduced from the prototype event vertex <code>pushed</code> of
    <code>Button</code>.</p>

    <pre class="code">&lt;watch&gt; <span class="watch">1</span>
  &lt;get select="Plus" event="pushed"/&gt;
  &lt;set property="n" value="`n + 1"/&gt;
&lt;/watch&gt;</pre>

    <figure>
      <img src="fig/graph-watch-671.svg">
      <figcaption>The watch sub-graph for watches <span class="watch">6</span>,
      and <span class="watch">7</span> of <code>Button</code>, and <span
        class="watch">1</span> of <code>Panel</code>.</figcaption>
    </figure>


    <h3>Edge Sorting</h3>
    <p>Once the graph <em>G</em> is built, its <code>edges</code> are sorted in
    topological order. Starting from vertices that have no outgoing edge (there
    is always at least one such vertex, the <code>vortex</code>), incoming edges
    are inserted at the beginning of the sorted list of edges in order of
    priority (the relative order of edges with the same priority is irrelevant)
    and removed from the list of outgoing edges their source vertex.</p>
    <p>The process repeats with the vertices which do not have any outgoing edge
    anymore. If there were no cycles in the graph, all edges and vertices are
    processed, otherwise an error is raised (although cycles may be broken when
    they include <em>delayed edges</em> as detailed below.)</p>
    <pre class="code">sort-watch-graph(WatchGraph G) = G.edges &lt;- sort-edges(G.edges)
<span class="TODO">Edge* sort-edges(Edge* E) = ...</span></pre>


    <h3>Example</h3>
    <p>The figure below shows the rendered graph for <code>Panel</code>.
    Vertices are represented by ovals (properties), heptagons (events),
    squares (watches), and a triangle for the vortex. Edges are represented
    by arrows between the vertices; <code>InheritEdges</code> are pink while
    yellow edges are edges that were copied from the prototype vertex. In this
    case, there is an edge from the <code>enabled</code> property vertex of
    <code>Button</code> to <span class="watch">8</span>, which is copied to the
    <code>enabled</code> property vertex of <code>Minus</code>.<span
      class="TODO"> Number the edges from the sort order.</span></p>

    <figure>
      <img src="fig/graph-panel.svg">
      <figcaption>The watch graph for the <code>Panel</code>
      component.</figcaption>
    </figure>

    <h3>Minimization and Compilation of the Watch Graph</h3>
    <p>As a possible optimization, the watch graph can be minimized by removing
    redundant edges and vertices after sorting. The remaining edges are kept in
    the original order.</p>
    <ul>
      <li>An <code>InheritEdge</code> can be removed by merging the source and
      destination vertices, and removing all copied edges from the destination
      vertex.</li>
      <li>A <code>WatchVertex</code> with exactly one incoming edge and one
      outgoing edge can be removed by creating a new edge between the source
      vertex of the incoming edge and the destination vertex of the outgoing
      edge. A new <code>Adapter</code> can be created for this edge by composing
      the match and value functions. Note that although removing a
      <code>WatchVertex</code> with two incoming edges and one outgoing edge,
      or one incoming edge and two outgoing edges would still reduce the number
      of edges in the graph, the semantics of graph traversal would not be
      preserved as either the input value or the output value of the
      <code>WatchVertex</code> would have to be computed twice, which may lead
      to undesireable side effects. (This would be possible if the absence of
      side effects were guaranteed.)</p>
    </ul>
    <p>After applying these steps whenever possible, the graph only contains
    <code>AdapterEdge</code>s. Cycles may appear as a result of merging
    vertices, but this does not result in infinite loops.<span
      class="TODO"> TODO: actual algorithm, and proof that the order is
      maintained.</span> For the sake of simplicity, furhter discussion of the
    watch graph will refer to the unminimized version of the graph.</p>

    <figure>
      <img src="fig/graph-panel-min.svg">
      <figcaption>The minimized watch graph for the <code>Panel</code>
      component.</figcaption>
    </figure>

    <p>The figure below shows how a watch graph may include a cycle after
    minimization. On the left is the original graph, and on the right is the
    minimized graph. The origin of the cycle is that setting a property
    <em>P</em> on <em>C</em> after it has changed on <em>B</em> (where both
    <em>B</em> and <em>C</em> inherit from a component <em>A</em>) results in an
    edge that has its source and destination in different vertices before
    minimization, but which have been merged in the minimized version.</p>
    <figure>
      <img src="fig/graph-min-cycle.svg">
      <figcaption>Introduction of a cycle in a minimized watch
      graph.</figcaption>
    </figure>

    <p>Another optimization consists in <em>compiling</em> the graph into code.
    A set of functions can be compiled for the input vertices of the graph;
    instead of setting an initial value on an input vertex <em>V</em> and
    initiating a traversal of the watch graph, the function
    <em>F<sub>V</sub></em> compiled from <em>V</em> is called instead. These
    functions call each other to implement the full graph traversal.<span
      class="TODO"> This section needs to be developed.</span></p>


    <h2>Rendering to HTML</h2>
    <p>The view of a component is rendered to HTML by creating its <em>view
      stack</em> and rendering that stack into a HTML element, such as the
    <code>body</code> of a document, a <code>div</code>, or an
    <code>iframe</code>.</p>

    <pre class="code">render-component-view(Component C, DOM element T) = render-view-stack(view-stack(C), T)</pre>

    <h3 id="view-stack">The View Stack</h3>
    <p>The <em>view stack</em> of a component is the stack of the views of the
    component, its prototype, its prototype’s view, and so on. The views along
    the prototype chain are actually new views created from the original views
    so that a component may modify its version of a view in the view stack
    without affecting other components created from the same prototype. For a
    <code>Component</code> <em>C</em>, the bottom-most view in the stack
    (<em>i.e.</em>, the first element in the list of views returned by
    <code>view-stack(C)</code>, with index 0) is a view of the furthest
    prototype, while the last element in the list is the view of <em>C</em>.
    Because components always have a view but may not have a prototype, the view
    stack has a length of 1 (for components with no prototype) or more (for
    components with a prototype.)</p>
    <pre class="code">View+ view-stack(Component C) = bottom-view-stack(C) : C.view
View+ view-stack’(Component C) = bottom-view-stack(C) : clone-element(C.view)
View+ bottom-view-stack(Component C) = if defined C.prototype
                                         then view-stack’(C.prototype)
                                         else []</pre>

    <p>The <code>clone-element(E, P)</code> function creates a copy of a
    <code>Node</code> <em>E</em> and its children and add it as a child of its
    parent <em>P</em>. In the case of a <code>View</code> element, a clone of
    the <code>Component</code> is also created for the <code>component</code> of
    the view, while maintaining the parent/children relationships of the
    component tree (so that in effect view tree and component tree are cloned in
    parallel.)</p>
    <pre class="code">Element clone-element(Element E, Element? P) =
  let E’ = create(E) in
    do
      E’.parent &lt;- P
      E’.children = map(E.children, λC clone-element(C, E’))
      if E’ is-a View and defined P
        clone-component(E’)
      E’</pre>
    <p>When a view <em>V</em> that is not the view of a top-level component is
    cloned, a clone of the component of <em>V</em> is made as well, so that this
    component can keep its own state independently of its prototype. The clone
    is <em>shallow</em>, because the children of the component will be cloned
    when the <code>View</code> children of <em>V</em> will be cloned. The
    hierarchy of the component tree is not preserved, but it is not required for
    the copies. Lastly, the component of the top-level view is never cloned
    because its state is maintained by the component that this is the prototype
    of.</p>
    <pre class="code">clone-component(View V) =
  let C’ = create(V.component)
    in
      V.component &lt;- C’
      C’.view &lt;- V</pre>

    <p>To illustrate the process, consider the following component tree. Black
    arrows point from parent to child, while pink arrows point from component
    to prototype. In this example, a component <em>A</em> has two children
    <em>B<sub>1</sub></em> and <em>B<sub>2</sub></em> which both inherit from
    <em>B</em>, which itself has two children, <em>C</em> and <em>D</em>.</p>

    <figure>
      <img src="fig/view-stack-1.svg">
      <figcaption>Static component tree (before rendering.)</figcaption>
    </figure>

    <p>The complete tree of views after the view stacks have been created is
    shown below. The pink lines indicate views in the same stack. It can be
    seen that the view of <em>B</em> was cloned twice into <em>B’</em> and
    <em>B”</em>, for the view stack of <em>B<sub>1</sub></em> and
    <em>B<sub>2</sub></em>; and likewise for its children <em>C</em> and
    <em>D</em>.</p>

    <figure>
      <img src="fig/view-stack-2.svg">
      <figcaption>The rendered view tree of <em>A</em>.</figcaption>
    </figure>

    <p>Finally, the component tree after the view stack was created is shown
    below. Note that while <em>B</em> was not cloned, because it is a top-level
    component, <em>C</em> and <em>D</em> have both been cloned twice. The dashed
    arrows indicate that the parent/child relationships are not maintained for
    copies of component (since B is not copied, the parent of C’ is still B,
    but B does not have C’ as its child) but this relationship is only pertinent
    in the static tree.</p>
    <figure>
      <img src="fig/view-stack-3.svg">
      <figcaption>Dynamic component tree (after the view stack was
      created.)</figcaption>
    </figure>

    <h3>Rendering Elements in a View Stack</h3>
    <p>Rendering a view stack <em>S</em> in a target DOM element <em>T</em> is
    simply rendering the bottom-most view in the stack, <em>i.e.</em> the
    element at index 0 in the list of <code>View</code>s.</p>
    <pre class="code">render-view-stack(View+ S, DOM element T) = render-element(S<sub>0</sub>, T, S, 0)</pre>

    <p>Rendering an element <em>E</em> from the view at index <em>I</em> in the
    view stack <em>S</em> in a target DOM element <em>T</em> depends on the type
    of the element to render.</p>
    <pre>render-element(Element E, DOM element T, View+ S, integer I) =
  case E of
    View = render-view(E, T, S, I)
    Content = render-content(E, T, S, I)
    DOMElement = render-dom-element(E, T, S, I)
    Attribute = render-attribute(E, T)
    Text = render-text(E, T)</pre>

    <p>Rendering a <code>View</code> element depends on whether the view is a
    member of the view stack, <em>i.e.</em>, the view of the component or of one
    of its prototypes; or the view of a child component. In the former case, the
    child elements of the view are rendered in the target element. In the latter
    case, <code>render-component-view</code> is callled on the child
    component.</p>
    <pre>render-view(View V, DOM element T, View+ S, integer I) =
  if V = S<sub>I</sub>
    then render-children(V, T, S, I)
    else render-component-view(V.component, T)
render-children(Element E, DOM element T, View+ S, integer I) =
  for C in E.children
    render-element(C, T, S, I)</pre>

    <p>Rendering a <code>Content</code> element depends on the view stack. If
    there is a non-default <code>View</code> above the current
    <code>View</code> in the stack, then render that view. If no such view
    exists, then render the children of the element as the default content using
    <code>render-children</code> as seen above.</p>
    <pre>render-content(Content C, DOM element T, View+ S, integer I) =
  let J = next-view-index(S, I + 1) in
    if J &lt; length S
      then render-view(S<sub>J</sub>, T, S, J)
      else render-children(C, T, S, I)
integer next-view-index(View+ S, integer I) =
  if I &lt; length S
    then if S.default
      then next-view-index(S, I + 1)
      else I
    else I</pre>

    <p>Rendering a <code>DOMElement</code> <em>D</em> is adding a new DOM
    element <em>N</em> to <em>T</em>, then rendering the children of <em>D</em>
    in <em>N</em>.</p>
    <pre>render-dom-element(DOMElement D, DOM element T, View+ S, integer I) =
  let N = new DOM element node in
    do
      N.namespace-uri &lt;- D.ns
      N.local-name &lt;- D.name
      N.attributes &lt;- D.attrs
      render-children(D, N, S, I)
      append-child(T, N)</pre>

    <p><span class="TODO">When the element is the target of an event, a DOM
    event listener is also added.</span></p>

    <p>Rendering an <code>Attribute</code> <em>A</em> is setting an attribute on
    the target element with the value resulting from the concatenation of the
    text value of the child elements of <em>A</em>.</p>
    <pre>render-attribute(Attribute A, DOM element T) =
  set-attribute-ns(T, E.ns, E.name, fold(E.children, "",
                                         λZ,C Z :: (case C of
                                                      Text = C.text,
                                                       otherwise = "")))</pre>

    <p>Rendering a <code>Text</code> element <em>E</em> is adding a new text
    node to <em>T</em> with the text content of <em>E</em>.</p>
    <pre>render-text(Text E, DOM element T) =
  let N = new DOM text node in
    do
      N.text-content &lt;- E.text
      append-child(T, N)</pre>


    <h2>Watch Graph Traversal</h2>

    <p><span class="TODO">Set values in the vertices, associated with a
    context (component+reference component). Values should not be overwritten?
    That would need reversing the priority of the edges.</span></p>

    <p>The watch graph is traversed when one of its <em>input vertices</em>
    is activated with a value. Edges of the graph are then traversed in the
    sorted order. Edges have different effects on the application, such as
    setting property values, generating events, modifying rendered elements,
    &amp;c. The order of the edges defines the order in which these changes
    occur. After all edges have been visited, vertex values are cleared until
    the next traversal.</p>

    <h3>Input Vertices and Vertex Values</h3>
    <p>Both a <code>PropertyVertex</code> and an <code>EventVertex</code> can
    act as input vertices and be <em>activated</em>. A
    <code>PropertyVertex</code> is activated when the corresponding property is
    set to a new value programmatically. An <code>EventVertex</code> is actiaved
    when the corresponding event notification is received.</p>
    <p>A vertex represents a <code>Watch</code> or <code>Adapter</code> for a
    </p>

    <p><span class="TODO">Replace scope with context</span>.<p>

    <div class="def" id="VertexValue">
      <p>A <code>VertexValue</code> is a value associated with a
      <code>Vertex</code> and a <code>Context</code> during graph traversal. The
      value itself can be any <code>data</code>.</p>
      <div>
        <pre>VertexValue = (Scope, data)</pre>
        <ul>
          <li>A <code>Vertex</code> in a <code>Graph</code> can have zero or
          more associated values, which can be retried with the function
          <code>VertexValue* get-vertex-values(Graph G, Vertex V)</code>.</li>
          <li>A <code>VertexValue</code> can be set for a <code>Vertex</code> in
          a <code>Graph</code> with the function <code>set-vertex-value(Graph G,
            Vertex V, VertexValue W)</code>. Any previous value with the same
          <code>Scope</code> is replaced with the new value, otherwise a new
          value is added to the list of values.</li>
          <li>All vertex values can be cleared from a <code>Graph</code> with
          the function <code>clear-vertex-values(Graph G)</code>.</li>
        </ul>
      </div>
    </div>


    <h3>Edge Traversal</h3>
    <p>Every edge of the graph is visited in turn.</p>
    <pre class="code">traverse-graph(Graph G) =
  do
    for E in G.edges
      traverse-edge(E)
    clear-vertex-values(G)</pre>

    <p>Traversing and edge means filtering input values (from the source
    vertex), computing output values, and <em>applying</em> them.</p>
    <pre class="code">traverse-edge(Edge E) =
  for (S, V) in get-vertex-values(G, E.source)
    let S’ = enter-scope(E, S) in
      if defined S’ and match-edge(E, S’, V)
        let V’ = apply-edge(E, S’, V) in
          for S” in exit-scopes(E, S’)
            set-vertex-value(G, E.dest, (S”, V’))</pre>

    <p>Enter scope: InheritEdge and edges to a watch vertex.</p>
    <pre class="code">Scope? enter-scope(Edge E, Scope S) =
  case E of
    InheritEdge = enter-scope-inherit(E, S)
    AdapterEdge = case E.dest of
                    WatchVertex = enter-scope-get(E, S)
                    otherwise = S
    otherwise = S</pre>

    <p><code>enter-scope-inherit</code> handles the case of an
    <code>InheritEdge</code>.</p>
    <pre class="code">Scope? enter-scope-inherit(InheritEdge E, Scope S) =
  find(stack-of(S), λN </pre>

    <p><code>enter-scope-get</code> handles the enter scope for an
    <code>AdapterEdge</code> </p>

Scope? enter-scope-get(AdapterEdge E, Scope S) =</pre>

    <p>The <code>match-edge</code> function is a predicate used to filter input
    values for an edge using the <code>match</code> function of the adapter of
    the edge. Remember that the default value for <code>match</code> is a
    function that returns true.</p>
    <pre class="code">boolean match-edge(Edge E, Scope S, data V) = E.adapter.match(V, S)</pre>

    <p>The <code>apply-edge</code> function has two roles:</p>
    <ol>
      <li>compute the input value of the edge from its input value;</li>
      <li>apply the value according to the type of edge.</li>
    </ol>
    <pre class="code">data apply-edge(Edge E, Scope S, data V) =
  case E of
    AdapterEdge = apply-edge’(E, S, V)
    otherwise = V
data apply-edge’(Edge E, Scope S, data V) =
  let V’ = E.adapter.value(V, S) in
    do
      case E.adapter of
        SetProperty = apply-property(E.adapter, S, V)
        SetAttribute = apply-attribute(E.adapter, S, V)
        SetEvent = apply-event(E.adapter, S, V)
        otherwise = nothing
      V’
    </pre>

    <p>Exit scopes</p>
    <pre class="code">Scope* exit-scope(Edge E, Scope S) =
  if E is-a AdapterEdge and E.source is-a WatchVertex
    then exit-scope’(E, S)
    else S
Scope exit-scope’(AdapterEdge E, Scope S) =</pre>

    <h3>Example</h3>
    <p>Using the example graph shown above, the process of graph traversal is
    illustrated in the figure below. The relevant state of the application at
    the instant before graph traversal begins is as follows:</p>
    <ul>
      <li>The <code>n</code> property of <code>Panel</code> has value 2.</li>
      <li>The <code>down</code> property of <code>Plus</code> has value true
      (the button has been pressed.)</li>
      <li>The <code>frame</code> of <code>Plus</code> has just received a
      <code>mouseup</code> event.</li>
    </ul>

    <figure>
      <img src="fig/graph-traverse.svg">
      <figcaption>Graph traversal after a <code>mouseup</code> event in the
      <code>Plus</code> child of the <code>Panel</code> component. </figcaption>
    </figure>

    <p>The <code>mouseup</code> event vertex was just activated for the
    <code>Plus</code> button with an event value. The graph traversal then
    starts, following edges in the order below (dashed edges are not followed
    as they have no input value and are omitted for brevity), with the following
    effects:
    <ol>
      <li>A DOM event is received from the <code>frame</code> DOM element of the
      clone of the view of <code>Button</code> for the <code>Plus</code>
      component (abbreviated <code>Button/Plus</code>.)</li>
      <li>The <code>down</code> property of <code>Plus</code> is set to
      false.</li>
      <li>The <code>down</code> property of <code>Plus</code> is passed to
      <span class="watch">7</span>.</li>
      <li>The <code>class</code> of the view <code>Button/Plus</code> is set to
      "".</li>
      <li>A <code>pushed</code> event is generated for the <code>Plus</code>
      component.</li>
      <li>This <code>InheritEdge</code> cannot be followed because
      <code>Plus</code> is not in the view stack of <code>Minus</code>.</li>
      <li>This <code>InheritEdge</code> is followed for <code>Plus</code> with
      the generated event as the value.</li>
      <li>The event value from <code>Plus</code> is passed to
      <span class="watch">1</span>.</li>
      <li>The property <code>n</code> of <code>Panel</code> is set to 3.</li>
      <li>The property <code>n</code> of <code>Panel</code> is passed to
      <span class="watch">3</span>.</li>
      <li>The property <code>enabled</code> of <code>Minus</code> is set to
      true.</li>
      <li>The property <code>enabled</code> of <code>Minus</code> is passed to
      <span class="watch">8</span>.</li>
      <li>The DOM text node <code>text-n</code> of <code>Panel</code> is updated
      to show the text "3".</li>
      <li>The <code>class</code> attribute of the <code>frame</code> of
      <code>Button/Minus</code> is set to "".</li>
    </ol>

    <h3>Delayed edge traversal</h3>
    <p><code>Adapter</code>s have a <code>delay</code> property. If that delay
    is a positive number, then the traversal of the edge corresponding to that
    adapter is <em>delayed</em>. No value is set on the target vertex, but a
    new graph traversal is scheduled to take place after the delay has elapsed.
    If the delay was 0, then the new traversal happens as soon as possible after
    the current traversal has ended; otherwise, a timer is set to start the
    traversal after the amount of time given by <code>delay</code>. Note that
    several delayed traversals may be scheduled from a given graph
    traversal.</p>
    <p>In the example traversal above, the <code>SetEvent</code> of <span
    class="watch">6</span> should have a delay of 0 so that the event is
    dispatched asynchronously. This means that edges 1 through 4 are traversed
    as above, but edge 5 is delayed. After the traversal has ended, a new
    traversal starts from edge 5, with the false value on the <code>Plus</code>
    button, and edges 6 through 14 are traversed as usual.</p>
    <p>Delayed edge traversal allows the graph to contain cycles, as long as at
    least one edge in the cycle has a delay. When sorting the edges of the
    graph, all edges with a delay are pushed back to the end of the list of
    edges, then the remaining edges can be sorted since possible cycles have
    been broken. Note that while this ensures that the edges can be sorted,
    in order to avoid an infinite number of traversal, there must be conditional
    edges (<em>i.e.</em>, edges for which the <code>match</code> predicate is
    not always true) in every cycle as well.</p>


    <h2>Property Initialization</h2>
    <p><span class="TODO">Property vertices are initialized with the initial
    value of the <code>Adapter</code>. Reverse order of priority so that values
    are never overwritten and store initial values on vertices.</span></p>

    <pre class="code">init-properties(Component C, Graph G) = ...</pre>

    <h3>Example</h3>

    <figure>
      <img src="fig/graph-init.svg">
      <figcaption>Initialization of the graph of the <code>Panel</code>
      component.</figcaption>
    </figure>


    <h2>Component Mutations</h2>
    <p><span class="TODO">Re-render but keep previous values instead of initial
      values.</p>

  </body>
</html>
